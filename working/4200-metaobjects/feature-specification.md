# Metaobjects

Author: Erik Ernst

Status: Draft

Version: 1.1

Experiment flag: metaobjects

This document specifies the metaobjects feature, which is a feature that
allow a type `T` to be mapped into one or more kinds of objects known as
_metaobjects_ of that type. The main purpose of a metaobject is to serve as
a vehicle for late-bound invocations of static members and/or constructors
of the type `T`, but it is also possible to use the mechanism for other
purposes.

## Introduction

The _metaobjects_ feature allows programs to map a given type to an object,
known as a _metaobject_, which allows features associated with that type
such as static members and constructors to be supported without depending
on the exact type itself.

Current Dart only allows static members and constructors to be invoked by
specifying the exact declaration (of a class, mixin, etc) that contains
said static member or constructor declaration. For example, if a class `A`
declares a static method `foo` then we can call it using `A.foo(...)`, but
we can not call it using `X.foo(...)` where `X` is a type variable, even in
the case where the value of `X` at run time is `A`.

Here is an example:

```dart
// Define the interface that we wish to support.
abstract class Fooable<X> {
  String foo(X x);
}

// The `static implements` clause specifies that a
// metaobject for `A` supports the given interface.
class A static implements Fooable<A> {
  final String name;
  A(this.name);
  static String foo(A a) => "${a.name} fooing!";
}

// Ditto.
class B static implements Fooable<B> {
  final int size;
  B(this.size);
  static String foo(B b) => "B of size ${b.size} fooing!";
}

// Does not depend on `A` or `B`, but is still type safe.
void showFoo<X static extends Fooable<X>>(X x) {
  X.foo(x);
}

void main() {
  showFoo(A("MyA");
  showFoo(B(42));
}
```

This works because the type variable `X` is evaluated to an object when it
is used as the receiver in an expression like `X.foo(x)`. The
_static bound_ on `X` which is specified as `static extends Fooable<X>`
provides a compile-time guarantee that the actual argument that `X` is
bound to in any given invocation of `showFoo` will be a type such that
when it is evaluated as an expression, the resulting metaobject will have a
type which is a subtype of `Fooable<X>`. In particular, it has a `foo`
method that has a positional parameter of type `X`, so we can safely call
it as `X.foo(x)`.

In main, it is statically ensured that the actual type argument of the two
invocations of `showFoo` satisfy this requirement: In the first invocation
the inferred type argument is `A`, and this is OK because
`A static implements Fooable<A>`. Similarly for the second invocation with
the actual type argument `B`.

The semantics that actually makes the invocation of `foo` call the static
method of `A` respectively `B` is established by an implicitly induced
class for each class that has a `static implements` clause. This implicitly
induced class implements all members of the specified interface by
forwarding to a static member or a constructor of the class/mixin/... whose
type it is a metaobject for.

For example:

```dart
class MetaobjectForA implements Type, Fooable<A> {
  String foo(A a) => A.foo(a);
  bool operator ==(Object other) => ...;
  int get hashCode => ...;
}

class MetaobjectForB implements Type, Fooable<B> {
  String foo(B b) => B.foo(b);
  bool operator ==(Object other) => ...;
  int get hashCode => ...;
}
```

These classes are implicitly generated by the compiler/analyzer, so we
can't refer to them in user code (the real name is probably something like
`$xBz8_`, and it's certainly a fresh name such that it doesn't coincide
with any name that a developer has written). However, when a type variable
like `X` above is evaluated as an expression, the resulting metaobject will
be an instance of one of these classes.

These classes implement operator `==` and the getter `hashCode`, such that
they can behave the same as objects of type `Type` do today, when they are
obtained by evaluating a type as an expression.

The static type of the metaobject will be the implicitly induced class when
the type which is being evaluated as an expression is a compile-time
constant type (for example, `var myMetaObject = A;`). In the case where the
type is a type variable `X` that has a bound of the form `static extends I`
then the metaobject has a static type which is a subtype of `Type` and a
subtype of `I`. (An implementation is free to implicitly generate such
classes when needed, or it may represent this kind of type in some other
way if preferred.) This implies that we can use the members of `I` on
that metaobject, e.g., `X.foo(x)` in the example above.

As a special case (ensuring that this feature does not break existing
code), the result of evaluating a type that denotes a type introducing
membered declaration except extension types (that is, a class, mixin, mixin
class, or an enum) that does _not_ have a `static implements` clause has
static type `Type` and works exactly the same as today. So does the result
of evaluating a type that does not denote a declaration (that is, a
function type, a record type, special types like `dynamic`, union types
like `T?`  and `FutureOr<T>`, etc.)

The previous example showed how we can use metaobjects to provide access to
static members of a set of classes (or mixins, etc.) without depending on
the exact class (mixin, etc.) declaration. This basically means that we
have made the static members _virtual_, because we're calling them via
normal instance members (that is, virtual members, with all the usual OO
semantics) of the metaobject.

The next example illustrates how we can use metaobjects to call
constructors in a similar way (yielding 'virtual constructors'):

```dart
abstract class Creation<X> {
  X call();
  X named(int _);
}

class C<Y> static implements Creation<C<Y>> {
  C.named(int _): this();
}

class D static implements Creation<D> {
  factory D() = _DImpl;
  D.named(int _);
}

class _DImpl implements D {...}

X create<X static extends Creation<X>>() => X();

void main() {
  C<int> c = create();
  D d = create();
}
```

This illustrates that we can perform creation of instances of the given
type argument (denoted by `X` in the declaration of `create`), in spite of
the fact that the class `C` is generic (and the type argument `X` has the
value `C<int>`, that is, it carries the actual type arguments with it), and
the constructor in `C` that we're using is the implicitly induced 'default'
constructor whose name is `C` (we could have written this explicitly as
`C();` or `C(): super();`). In contrast, the constructor that we're using
in `D` is a redirecting factory constructor.

This works because the only requirement for a class `C` to static implement
`Creation<C>` is that it must have a declaration which can be invoked as an
invocation of the type itself (`C()`), which is exactly what we get the
ability to do when the metaobject has a `call` method (that is, we can do
`X()` when `X` denotes an object that has a `call` method).

The constructors named `C.named` and `D.named` are treated similarly except
that they are named. They can be invoked using expressions like
`X.named(42)` when `X` is a type variable that
`static extends Creation<X>`.

When a type introducing declaration (that is, a class/mixin/etc) has a
`static implements I` clause, the implicitly generated class which is used
to create metaobjects for said type will have an `implements I` clause, and
it is satisfied by generating forwarding instance members for each of the
members of the interface of `I`.

It is also possible to use a `static extends T` clause, in which case the
implicitly generated metaobject class will have an `extends T` clause. This
implies that the implicitly generated class can inherit behaviors from `T`
(and possibly implement others as forwarders, with members which are not
implemented otherwise).

For example:

```dart
abstract class CallWithTypeArguments {
  int get numberOfTypeArguments;
  R callWithTypeArgument<R>(int number, R callback<X>());
}

class _EStaticHelper<X, Y> implements CallWithTypeArguments {
  int get numberOfTypeArguments => 2;
  R callWithTypeArgument<R>(int number, R callback<Z>()) => switch (number) {
    1 => callback<X>(),
    2 => callback<Y>(),
    _ => throw ArgumentError("Expected number in {1, 2}, got $number."),
  };
}

class E<X, Y> static extends _EStaticHelper<X, Y> {
  const E();
  void foo(X x, Y y) {}
}

void main() {
  final E<Object, Object> e = E<String, int>();

  // When we don't know the precise type arguments we can't call
  // `e.foo` safely. But `CallWithTypeArguments` can help!
  final eType = e.runtimeType;
  eType.callWithTypeArgument(1, <X>() {
    eType.callWithTypeArgument(2, <Y>() {
      var potentialArgument1 = 'Hello';
      var potentialArgument2 = 42;
      if (potentialArgument1 is X && potentialArgument2 is Y) {
        a.foo(potentialArgument1, potentialArgument2); // Safe!
      }
    });
  });
  
  // If we didn't have this feature we could only do this:
  try {
    e.foo('Hello', 42); // May or may not throw.
  } catch (error) {
    // Some error recovery.
  }
}
```

The `static extends` clause allows metaobjects to have arbitrary
user-written code in members (not just forwarding members, as is the case
with `static implements`). 

In this example, we're using it to provide a very basic kind of an
'existential open' operation. That is, we provide support for executing
code in a scope where the actual value of each type parameter can be
denoted. In the example we use this capability to test whether or not the
given arguments have the required types.

Here is the corresponding implicitly induced metaobject class:

```dart
class MetoobjectForE<X, Y> extends _EStaticHelper<X, Y> implements Type {
  // All member implementations are inherited, except for the support
  // for `Type` equality. So we only have the following:
  bool operator ==(Object other) => ...;
  int get hashCode => ...;
}
```

In general, the static clauses and the regular subtype relationships are
independent. It is possible for two classes to have a subtype relationship,
and both of them may have a `static implements` or `static extends` clause,
but it is still possible for those static supertypes to be unrelated. Or
vice versa: the classes in the first example, `A` and `B`, are unrelated
classes, but they have the same static supertype.

This means that it is meaningful to have a regular bound on a type variable
as well as a static bound, because none of them is a consequence of the
other: `X extends SomeType static extends SomeOtherType`. This just means
that `X` is a subtype of `SomeType`, and a metaobject which is obtained by
evaluating `X` as an expression will be an object whose run-time type is a
subtype of `SomeOtherType`. However, even if we know that `Y extends X`,
we cannot conclude that `Y static extends SomeOtherType`.

Note that the latter could never be true: If `Y extends X` and 
`X static extends SomeOtherType` would actually imply that 
`Y static extends SomeOtherType` then the object which is obtained by
evaluating `Never` as an expression would have to have all types
because we can always write `X static extends C` for any class `C`,
so a metaobject for `Never` must, essentially, be an instance of
`Never`, and that _must_ be impossible (`Never` corresponds to the empty
set, so we can't promise that we can deliver an element that belongs to
this set).

In summary, this feature can be said to introduce support for virtual
static members, virtual constructors, and type related behaviors including
the ones that rely on having explicit access to the actual type arguments
of the given type.

## Specification

### Syntax

The grammar is adjusted as follows:

```ebnf
<staticSupertypes> ::= // New.
    'static' 'extends' <typeNotVoidNotFunction>
  | 'static' 'implements' <typeNotVoidNotFunctionList>

<classDeclaration> ::= // Modified.
    (<classModifiers> | <mixinClassModifiers>)
    'class' <typeWithParameters> <superclass>?
    <interfaces>? <staticSupertypes>?
    '{' (<metadata> <classMemberDeclaration>)* '}'
  | <classModifiers> 'mixin'? 'class' <mixinApplicationClass>

<mixinApplicationClass> ::= // Unchanged, included for readability
    <typeWithParameters> '=' <mixinApplication> ';'

<mixinApplication> ::= // Modified.
    <typeNotVoidNotFunction> <mixins> <interfaces>? <staticSupertypes>?

<mixinDeclaration> ::= // Modified.
    'base'? 'mixin' <typeWithParameters>
    ('on' <typeNotVoidNotFunctionList>)? <interfaces>? <staticSupertypes>?
    '{' (<metadata> <mixinMemberDeclaration>)* '}'

<enumType> ::= // Modified.
    'enum' <typeWithParameters> <mixins>? <interfaces>? <staticSupertypes>?
    '{' <enumEntry> (',' <enumEntry>)* (',')?
    (';' (<metadata> <classMemberDeclaration>)*)? '}'

<typeParameter> ::= // Modified.
    <metadata> <typeIdentifier> 
    ('extends' <typeNotVoid>)?
    ('static' 'extends' <typeNotVoidNotFunction>)
```

The modifications are generally that type introducing declarations (except
extension types) are extended to include `<staticSuperTypes>?`, and type
parameters are extended to include the corresponding static bound.

### Static Analysis

Assume that _D_ is a class declaration named `C` which has a clause of the
form `static implements T` or `static extends T`.

A compile-time error occurs if `T` is not an interface type. A compile-time
error occurs if `C` does not declare a set of static members and/or
constructors such that every member of `T` can obtain a correctly
overriding implementation by implicitly inducing a forwarding member to a
static member or constructor of `C`.

A compile-time error occurs if the metaobject class derived from _D_ has
any errors.

#### Deriving Forwarding Members

Assume that _D_ is a class declaration named `C` which has a clause of the
form `static implements T` or `static extends T`, and declares the formal
type parameters `X1 extends B1 .. Xk extends Bk`.

Forwarding members are derived from the static members and as follows:

If `static R get g ...` is a static member of `C` then the corresponding
forwarding member is `R get g => C.g;`.

If `static set s(parm) ...` is a static setter of `C` where `parm` is
derived from `<normalFormalParameter>`, then the corresponding forwarding
setter is `set s(parm) => C.s = arg;`, where `arg` is the identifier which
is declared as a positional parameter by `parm`.

*Static variable declarations are covered as getters and/or setters.*

If `static R m(parms)` is a static method of `C` where `parms` is derived
from `<formalParameterList>`, then the corresponding forwarding method is
`R m(parms) => C.m(args);`, where `args` is a comma separated list of
identifiers declared as positional parameters in `parms`, followed by
actual arguments of the form `id: id` for the named parameters in `parms`.

Similarly, if `static R m<typeParms>(parms)` is a static method of `C`
where `typeParms` is derived from `<typeParameter> (',' <typeParameter>)*`
and `parms` is derived from `<formalParameterList>`, then the corresponding
forwarding method is `R m<typeParms>(parms) => C.m<typeArgs>(args);`, where
`typeArgs` is a comma separated list of the type variables declared in
`typeParms` in declaration order, and `args` is a comma separated list of
identifiers declared as positional parameters in `parms`, followed by
actual arguments of the form `id: id` for the named parameters in `parms`.

*Note that the type parameter bounds and optional parameter default values
are the same for the original declaration and the forwarding
declaration. This works because the implicitly induced class is placed
in the same scope as the original declaration.*

If `C(parms) ...` or `factory C(parms) ...` is a constructor declared by `C`
then the corresponding forwarding declaration is
`C<X1 .. Xk> call(parms1) => C(args);`, here `args` are derived from `parms1`
in the same way as with the static method above, and `parms1` is derived
from `parms` by erasing `this.` and `super.` and inserting the inferred
types and default values that are implied by `this.` and `super.` in the
cases where those declared types and default values have been omitted.

If `C.name(parms) ...` or `factory C.name(parms) ...` is a constructor
declared by `C` then the corresponding forwarding declaration is
`C<X1 .. Xk> name(parms1) => C.name(args);`, here `args` are derived from
`parms1` in the same way as with the static method above, and `parms1` is
derived from `parms` in the same way as in the previous case.

#### Deriving the Metaobject Class

Assume that _D_ is a class declaration named `C` which has a clause of the
form `static implements T` or `static extends T`, and declares the formal
type parameters `X1 extends B1 .. Xk extends Bk`.

The _metaobject class_ for _D_ is an implicitly induced class which is
located in the same scope as _D_.

The name of the metaobject class is a fresh name, say, `MetaC`. The
implicitly induced metaobject class for _D_ is then as follows in the case
where the clause is `static implements T`:

```dart
class MetaC<X1 extends B1 .. Xk extends Bk> implements Type, T {
  // Implicitly induced member implementations, obtained by
  // deriving forwarding declarations from static members and/or
  // constructors in `C`, including only the ones needed to
  // implement `T` plus operator `==` and `hashCode` to support
  // today's behavior of `Type` instances.
  ...
}
```

In the case where the clause is `static extends T` we have the following:

```dart
class MetaC<X1 extends B1 .. Xk extends Bk> 
    extends T implements Type {
  // Implicitly induced member implementations, same rules.
  ...
}
```

### Dynamic Semantics

In the case where a type `T` is introduced by a declaration that has a 
`static implements` or a `static extends` clause, the step whereby a given
type is evaluated as an expression is changed such that the resulting
metaobject is an instance of the implicitly induced metaobject class,
passing the same actual type arguments as the ones which are part of `T`.

*For example, if we are evaluating a type parameter `X` as an expression,
and the value of `X` is a type `C<S1, S2>` that has a metaobject class
`MetaC` then the result will be an instance of `MetaC<S1, S2>`.*

The metaobject has standard semantics, everything follows the normal rules
of Dart based on the metaobject class declaration.

### Changelog

1.0 - Mar 28, 2025

* First version of this document released.

# Augmentation Libraries

Author: rnystrom@google.com, Version: 1.7 (see [Changelog](#Changelog) at end)

Augmentation libraries allow splitting a Dart library into files. Unlike part
files, each augmentation has its [own imports][part imports] and top-level
scope. Augmentations can add new top-level declarations, inject new members into
classes, and wrap functions and variables in additional code.

[part imports]: https://github.com/dart-lang/language/issues/519

## Motivation

Dart libraries are the unit of code reuse. When an API is too large to fit into
a single file, you can usually split it into multiple libraries and then have
one main library export the others. That works well when the functionality in
each file is made of separate top-level declarations.

However, sometimes a single *class* declaration is too large to fit comfortably
in a file. Dart libraries and even part files are no help there. Because of
this, users have asked for something like partial classes in C# ([#252][] 45 ðŸ‘,
[#678][] 15 ðŸ‘). C# also supports splitting [the declaration and implementation
of methods into separate files][partial].

[#252]: https://github.com/dart-lang/language/issues/252
[#678]: https://github.com/dart-lang/language/issues/678
[partial]: https://github.com/jaredpar/csharplang/blob/partial/proposals/extending-partial-methods.md

### Generated code

Size isn't the only reason to split a library into multiple files. Code
generation is common in Dart. [AngularDart][] compiles HTML templates to Dart
files. The [freezed][] and [built_value][] packages generate Dart code to
implement immutable data structures.

[angulardart]: https://github.com/angulardart
[freezed]: https://pub.dev/packages/freezed
[built_value]: https://pub.dev/packages/built_value

In cases like this, it's important to have the hand-authored and
machine-generated code in separate files so that the code generator doesn't
inadvertently erase a user's code. AngularDart generates a separate library for
the component. The freezed and built_value packages generate part files.

### Macros

The language team is investigating adding [macros][] to Dart. In theory, this
would *reduce* the need for text-based code generation language features.
Instead of code generation, users could write macros instead. They'd let the
compiler expand them, and not worry about anything ending up on disk.

[macros]: https://github.com/dart-lang/language/blob/master/working/macros/feature-specification.md

If users never needed to fix bugs in macros, look at stack traces, step into
code in a debugger, or navigate to the location of a compile error, that would
be true. But understanding and digging into code is fundamental to programming.
An error could be thrown from code generated by a macro. A macro might generate
code that produces a compile error (either deliberately because the macro was
misused or because the macro itself has a bug). A user might be profiling their
application and a macro might generate particularly slow code.

In all of those cases, users need some way to read and understand code produced
by macros. So, even if that code is generated automatically by the compiler as
part of macro expansion, it's still useful to have it be in a canonical
well-specified form that users can understand.

This proposal defines that format. The idea is that a Dart compiler executes
macros and then produces one or more augmentation library files that contain all
of the changes that the macros made to the library where they are applied. The
language then automatically merges those augmentations into the main library.

But augmentations aren't *only* a serialization format for macros. They are a
first-class language feature that can be produced by non-macro code generators
or written by hand by users who simply want to break a giant library or class
into smaller files.

## Augmentation libraries

An augmentation library is a separate file that *augments* another *main*
library. An augmentation is somewhere between a separate library and a part
file.

*   Like a library, it may contain all kinds of declarations&mdash;functions,
    classes, variables, etc.

*   Like a library, it has its own import scope and may contain its own imports.

*   Like a part file, all of the top-level declarations it produces end up in
    the top-level scope of the main library.

*   Like a part file, it shares a private scope with the main library and the
    two have mutual access to private declarations in the other file.

Augmentations have a few features unique to them:

*   An augmentation may add new members to existing types in the main library.

*   A function in the augmentation may wrap the body of a function in the main
    library.

*   A variable in the augmentation may wrap the initializer of a variable in the
    main library.

These can't be expressed today using only imports, exports, and part files.

### Defining an augmentation

An augmentation has almost the same syntax and semantics as a normal Dart
library. Augmentations are distinguished by a special `library` directive with
an `augment` modifier, like so:

```dart
library augment 'main_library.dart';
```

**TODO: Better syntax? How does this interact with [import short-hand
syntax][import]?**

[import]: https://github.com/dart-lang/language/blob/master/working/0649%20-%20Import%20shorthand/proposal.md

The URL points to the main library that this augmentation is applied to.

After that, an augmentation library may contain anything a regular Dart library
can contain: imports, exports, classes, functions, constants, etc. All
augmentations of a main library share the same top level declaration scope.
Declarations in any augmentation or the main library are visible to all of the
others, including private ones.

However, augmentations do *not* share an import scope with the main library or
each other. The libraries one augmentation imports are visible only to that
file.

It is a compile-time error if:

*   A top-level declaration in an augmentation has the same name as a
    declaration in the main library or another of its augmentations (unless it
    is an *augmenting* declaration, described below). *This is the same error
    conceptually as having a name collision in one file.*

*   An augmentation library contains any `part` directives.

### Applying an augmentation library

A main library applies an augmentation to itself using a new import directive
that looks like this:

```dart
import augment 'some_augmentation.dart';
```

This directive tells the compiler to read the given library augmentation and
merge its declarations into this library. It is a compile-time error if:

*   The library referenced in an `import augment` directive is not an
    augmentation and does not have a `library augment` directive.

*   The library referenced in a `library augment` directive does not have an
    `import augment` directive pointing back to this augmentation.

*   The same augmentation library is applied more than once. *In other words,
    you can't have redundant `import augment` directives that point to the same
    library.*

Since the main library and its augmentation both point to each other, these
rules imply that a given augmentation file can only be used to augment a single
library.

### Merge order

A library may apply multiple augmentations to itself. Also, augmentation files
may themselves contain `import augment` directives. The entire tree of
augmentations is recursively applied to the main library. The merge order is
defined as a depth-first pre-order traversal of the `import augment` directives
starting at the main library.

For example:

```
// main.dart
import augment 'a.dart';
import augment 'c.dart';

class C {}

void trace() {
  print('main');
}

// a.dart
library augment 'main.dart';

import augment 'b.dart';

augment class C {}

augment void trace() {
  augment super.trace();
  print('a');
}

// b.dart
library augment 'a.dart';

class D {}

augment void trace() {
  augment super.trace();
  print('b');
}

// c.dart
library augment 'main.dart';

augment class D {}

augment void trace() {
  augment super.trace();
  print('c');
}
```

The merge order is `main.dart`, `a.dart`, `b.dart`, then `c.dart`. The
declarations in those libraries&mdash;new declarations or augmentations&mdash;
are processed in that order.

This order is user-visible in two ways:

*   A non-augmenting declaration must appear first before it can be augmented.
    For example, `C` in `main.dart` is augmented by `C` in `a.dart`. Likewise,
    `D` in `b.dart` is augmented by `D` in `c.dart`. Note that the latter is
    allowed even though `b.dart` does not itself import `c.dart`.

*   When the same declaration is augmented multiple times, merge order
    determines the order that those wrappers are applied. When the `trace()`
    function is called, it prints:

    ```
    main
    a
    b
    c
    ```

**TODO: Should it be a compile-time error if the main library and augmentation
are in different packages?**

**TODO: Can the main library and augmentations have different language
versions?**

## Augmenting declarations

Unlike part files, which can only add entirely new declarations, an augmentation
can also modify existing declarations in the main library. This can mean adding
new members to an existing type, or even modifying the code of an existing
declaration. There are a few supported operations which are all marked
syntactically using an `augment` modifier.

Often, an augmentation wants to also preserve and run the code of the original
declaration it augments (hence the name "augmentation"). It may want run before
the original code, after it, or both. To allow that, we allow a new expression
syntax inside the bodies of augmenting members. Inside a member marked
`augment`, an expression like `augment super` can be used to refer to the
original function, getter, setter, or variable initializer.

**TODO: I'm not sold on `augment super`. Is there a better syntax?**

The same declaration can be augmented multiple times by separate augmentation
libraries. When that happens, the merge order defined previously determines
which order the wrapping is applied.

It is a compile-time error if:

*   An augmenting declaration has no corresponding original declaration to
    apply to.

*   An augmenting declaration appears in a library before the library where the
    original declaration occurs, according to merge order. *An augmentation
    library can both declare a new declaration and augment it in the same file.*

### Augmenting types

A class, mixin, enum, or extension declaration can be marked with an `augment`
modifier:

```dart
augment class SomeClass {
  // ...
}
```

This means that instead of creating a new type declaration, the augmentation
modifies a corresponding declaration in the main library or one of its other
augmentations.

All the keywords (other than `augment`) must be identical between the original
declaration and the augmentation. This is to ensure that looking at either one
will give a complete depiction of the capabilities of the type, and an
augmentation cannot introduce hidden restrictions.

A class or enum augmentation may specify `implements` and `with` clauses. When
those appear, the specified superinterfaces and mixins are appended to the main
class's superinterface and mixin lists, respectively.

**TODO: Is appending the right order for mixins?**

Any instance or static members defined in the body of the type are added to the
instance or static namespace of the corresponding type in the main library. In
other words, the augmentation can add new members to an existing type.

**TODO: Can an augmentation on enums add new enum cases?**

Instance and static members inside a type may themselves be augmentations. In
that case, they augment the corresponding members in the original type
declaration according to the rules in the following subsections.

It is a compile-time error if:

*   The augmenting type and corresponding type are not the same kind: class,
    mixin, enum, or extension. You can't augment a class with a mixin, etc.

*   The augmenting type and corresponding type do not have all the same
    modifiers (final, sealed, mixin, etc). This is not a technical requirement
    but it should make augmentations easier to understand when looking at them.

*   The augmenting type declares an `extends` clause. Only the main declaration
    can specify those.

    **TODO: We could consider allowing an `extends` clause if the main
    declaration doesn't have one.**

*   The type parameters of the type augmentation do not match the original
    type's type parameters. This means there must be the same number of type
    parameters with the same bounds.

    *Since repeating the type parameters is, by definition, redundant, this
    doesn't accomplish anything semantically. But it ensures that anyone reading
    the augmenting type can see the declarations of any type parameters that it
    uses in its body and avoids potential confusion with other top-level
    variables that might be in scope in the augmentation library.*

### Augmenting functions

A top-level function, static method, instance method, or operator may be
augmented to wrap the original code in additional code:

```dart
// Wrap the original function in profiling:
augment int slowCalculation(int a, int b) {
  var watch = Stopwatch()..start();
  var result = augment super(a, b);
  print(watch.elapsedMilliseconds);
  return result;
}
```

The augmentation replaces the original function body with the augmenting code.
Inside the augmentation body, a special `augment super()` expression may be used
to execute the original function body. That expression takes an argument list
matching the original function's parameter list and returns the function's type.

**TODO: Better syntax than `augment super`?**

The augmenting function does not have to pass the same arguments to `augment
super()` as were passed to it. It may call it once, more than once, or not at
all.

It is a compile-time error if:

*   The signature of the function augmentation does not exactly match the
    original function. This means the return types must be the same; there must
    be the same number of positional, optional, and named parameters; the types
    of corresponding positional and optional parameters must be the same; the
    names and types of named parameters must be the same; any type parameters
    and bounds must be the same; and any `required` or `covariant` modifiers
    must match.

    *Since repeating the signature is, by definition, redundant, this doesn't
    accomplish anything semantically. But it ensures that anyone reading the
    augmenting function can see the declarations of any parameters that it
    uses in its body.*

*   The function augmentation specifies any default values. *Default values are
    defined solely by the original function.*

*   The original function is declared `external` and the augmenting function
    uses `augment super()`.

    **TODO: Instead of making this an error, should we add a syntax that lets
    the augmentation dynamically detect whether there is an original body to
    wrap?**

**TODO: Should we allow augmenting functions to add parameters? If so, how does
this interact with type checking calls to the function?**

### Augmenting variables, getter, and setters

Augmentations on variables, getters, and setters are more complex because the
language treats those as [mostly interchangeable][uniform]. We want to preserve
that flexibility in augmentations. For example, an augmentation might want to
wrap access to a variable in an augmenting getter. Or an augmentation may want
to fill in the body of an unimplemented getter by using a backing variable
declaration.

[uniform]: https://en.wikipedia.org/wiki/Uniform_access_principle

You can think of variable, getter, and setter declarations all as ways to define
a higher-level "property" construct. A property has a name and a type. It may
have one or more other capabilities:

*   **A backing storage location.** You get this when you declare a variable.
    This also enables an instance variable to be assigned in a constructor
    initializer list. A variable may also have an **initializer** expression
    that gets run either lazily for top-level variables and static fields or at
    construction time when an instance is created.

*   **A getter function.** This function body is provided explicitly when you
    declare a getter. A variable declaration provides an implicit getter body
    that returns the value in the backing storage location. (Late variables do
    some additional checking in that implicit body.)

*   **A setter function.** A setter declaration provides this body explicitly. A
    non-final variable declaration provides an implicit setter body that stores
    the given value in the storage location. (Again, late variables do some
    additional checks.)

Declarations may be marked `abstract` or `external` and, if so, those are
mapped over to the corresponding getter and setter functions.

Augmentations on variables, getters, and setters works mostly at the level of
these separate capabilities. For example, augmenting a variable with a getter
replaces the variable's implicit getter body with the augmenting getter's.

More specifically:

*   **Augmenting with a getter:** A getter in an augmentation library can
    augment a getter in the main library or the implicit getter defined by a
    variable in the main library. Inside the augmenting body, an `augment super`
    expression invokes the original getter.

*   **Augmenting with a setter:** A setter in an augmentation library can
    augment a setter in the main library or the implicit setter defined by a
    non-final variable in the main library. Inside the augmenting setter, an
    `augment super =` expression invokes the original setter.

*   **Augmenting a getter and/or setter with a variable:** A variable in an
    augmentation library can augment a getter in the main library. A non-final
    variable can augment a setter as well. The implicit getter and setter
    defined by the augmenting variable replace the getter and setter in the main
    library.

*   **Augmenting a variable with a variable:** The original storage location is
    discarded and the original implicit getter and setter are replaced with the
    new implicit ones. *In most cases, the distinction of which implicit
    getter/setter is kept is not visible. But if augmenting a `late` variable
    with a non-`late` one or vice versa, the bodies behave differently in
    user-visible ways.*

    The original initializer expression is replaced with the augmenting
    variable's initializer if it has one. The augmenting initializer may use an
    `augment super` expression which executes the original initializer
    expression when evaluated.

    If the variable declaration in the original library does not have a type
    annotation, then the type is inferred only using the original library's
    initializer. (If there is no initializer in the original library, then the
    variable is inferred to have type `dynamic` like any non-augmented variable.
    *This ensures that augmenting a variable doesn't change its type. This is
    necessary to ensure that macros running after signatures are known can't
    change the signature of a declaration.*

    **TODO: What if the augmenting variable doesn't have an initializer?**

It is a compile-time error if:

*   The original and augmenting declarations do not have the same type.

*   An augmenting declaration uses `augment super` when the original declaration
    is marked `external`.

*   An augmenting initializer uses `augment super` and the original declaration
    is not a variable with an initializer.

*   A final variable is augmented with a setter. (Instead, the augmentation
    library can declare a *non-augmenting* setter that goes alongside the
    implicit getter defined by the final variable.)

*   A non-final variable is augmented with a final variable. We don't want to
    leave the original setter in a weird state.

*   A non-`late` augmenting instance variable initializer contains `augment
    super` and the variable being augmented is `late`. *Initializers for `late`
    instance variables have access to `this` while non-`late` variables do not.
    This means a `late` variable's initializer can't be called from a non-`late`
    variable's initializer.*

### Augmenting constructors

Constructors are (as always) more complex. A constructor marked `augment`
replaces the body of the corresponding constructor in the main library with its
body. If the augmenting constructor has any initializers, they are appended to
the original constructor's initializers, but before any original super
initializer or original redirecting initializer if there is one.

In the augmenting constructor's body, an `augment super()` call invokes the
original constructor's body.

It is a compile-time error if:

*   The signature of the constructor augmentation does not match the original
    constructor. This means the return types must be the same; there must be the
    same number of positional, optional, and named parameters; the types of
    corresponding positional and optional parameters must be the same; the names
    and types of named parameters must be the same; any type parameters and
    bounds must be the same; and any `required` or `covariant` modifiers must
    match. Any initializing formals must be the same in both constructors.

    **TODO: Is this the right way to handle initializing formals?**

*   The constructor augmentation specifies any default values. *Default values
    are defined solely by the original constructor.*

*   The original constructor is `const` and the augmenting constructor is not
    or vice versa.

*   The original constructor is a factory constructor and the augmenting
    constructor has an initializer list.

*   The original constructor has a super initializer or redirecting initializer
    and the augmenting constructor does too.

**TODO: What about redirecting constructors?**

### Metadata annotations and macro applications

An augmentation declaration may have metadata annotations or macro applications.
These are appended to the list of metadata annotations and macro applications on
the original declaration.

## Scoping

Like part files, the main library and all of its augmentations share a single
top-level scope where declarations are defined. They also share a single private
namespace. This means that private declarations in the main library or an
augmentation are visible to all augmentations.

Unlike part files, an augmentation library has its own import scope surrounding
that shared top-level scope. Any libraries the augmentation imports are visible
only to that augmentation library. Likewise, libraries imported by the main
library are not implicitly imported by the augmentation.

Exports in an augmentation library are applied to the main library and become
exports from the main library's namespace.

The static and instance member namespaces for an augmented type are shared
across the declaration of the type in the main library and all augmentations of
that type. Identifiers in the bodies of members (both implicit ones and explicit
uses like `this.` or `TypeName.`) are resolved against that complete merged
namespace. For example:

```dart
// Main library "some_lib.dart":
import augment 'some_augment.dart';

import 'other_lib.dart';

const a = 1;

class C {
  bool isEven(int n) {
    if (n == 0) return true;
    return !_isOdd(n - 1);
  }
}

// Augmentation "some_augment.dart":
library augment 'some_lib.dart';

import 'also_lib.dart';

const b = 2;

augment class C {
  bool _isOdd(int n) => !isEven(n - 1);
}
```

This code is fine. Code in C in the main library can refer to members added in
the augmentation library like `_isOdd()`. Meanwhile, code in the augmentation
can see members like `isEven()` declared in the main library.

You can visualize the namespace nesting sort of like this:

```
some_lib.dart       | some_augment.dart
                    |
.-----------------. | .-----------------.
| import scope:   | | | import scope:   |
| other_lib       | | | also_lib        |
'-----------------' | '-----------------'
         ^          |         ^
         |          |         |
.--------------------------------------.
| top-level declaration scope:         |
| const a                              |
| class C                              |
| const b                              |
'--------------------------------------'
         ^          |         ^
         |          |         |
.--------------------------------------.
| class C instance members:            |
| isEven()                             |
| _isOdd()                             |
'--------------------------------------'
         ^          |         ^
         |          |         |
.-----------------. | .-----------------.
| C.isEven() body | | | C._isOdd() body |
'-----------------' | '-----------------'
```

Each library has its own namespace chain from its own member bodies out to its
own import namespace. But in the middle, each passes through the shared class
namespaces for the instance and static members and the shared top level
declaration scope.

This implies that the bodies of members cannot be resolved until after
augmentations have been merged. We don't know what namespace `isEven()` or
`_isOdd()` will be found in until the namespace for the class has had *all*
augmentations merged in.

Fortunately, augmentations can be applied purely syntactically. In order to
merge augmentations into the main library, we only need to match declarations
by name. So a Dart compiler can theoretically:

1.  Parse the main library and all of its augmentations.
2.  Merge the augmentations to determine the complete set of declarations in
    all types.
3.  Resolve and type-check the main library and all of its augmentations now
    that all type namespaces are complete.

## Syntax

The grammar changes are fairly simple. A main library can apply an augmentation
using a new directive:

```
importOrExport ::= libraryImport
  | libraryAugmentImport
  | libraryExport

libraryAugmentImport ::= metadata 'import' 'augment' uri ';'
```

A library directive may contain `augment` followed by a URI to denote the file
as an augmentation library:

```
libraryName ::= metadata 'library'
    ( dottedIdentifierList | 'augment' uri ) ';'
```

In an augmentation library, the grammar is slightly modified to allow an
`augment` modifier before various declarations:

```
topLevelDeclaration ::= classDeclaration
  | mixinDeclaration
  | extensionDeclaration
  | enumType
  | typeAlias
  | 'external' functionSignature ';'
  | 'external' getterSignature ';'
  | 'external' setterSignature ';'
  | 'augment'? functionSignature functionBody
  | 'augment'? getterSignature functionBody
  | 'augment'? setterSignature functionBody
  | 'augment'? ('final' | 'const') type? staticFinalDeclarationList ';'
  | 'augment'? 'late' 'final' type? initializedIdentifierList ';'
  | 'augment'? 'late'? varOrType initializedIdentifierList ';'

classDeclaration ::=
  'augment'? 'abstract'? 'class' identifier typeParameters?
  // Rest of rule...

mixinDeclaration ::= 'augment'? 'mixin' identifier typeParameters?
  // Rest of rule...

classMemberDeclaration ::= declaration ';'
  | 'augment'? methodSignature functionBody

declaration ::= 'external' factoryConstructorSignature
  | 'external' constantConstructorSignature
  | 'external' constructorSignature
  | ('external' 'static'?)? getterSignature
  | ('external' 'static'?)? setterSignature
  | ('external' 'static'?)? functionSignature
  | 'external'? operatorSignature
  | 'augment'? 'static' 'const' type? staticFinalDeclarationList
  | 'augment'? 'static' 'final' type? staticFinalDeclarationList
  | 'augment'? 'static' 'late' 'final' type? initializedIdentifierList
  | 'augment'? 'static' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'covariant' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'late'? 'final' type? initializedIdentifierList
  | 'augment'? 'late'? varOrType initializedIdentifierList
  | 'augment'? redirectingFactoryConstructorSignature
  | 'augment'? constantConstructorSignature (redirection | initializers)?
  | 'augment'? constructorSignature (redirection | initializers)?
```

**TODO: Define the grammar for the various `augment super` expressions.**

It is a compile-time error if:

*   A function, getter, setter, or operator declaration marked `augment` is also
    abstract.

*   A declaration marked `augment` is also marked `external`.

## Static semantics

Previous sections informally describe the process of applying augmentations to
the main library, but here's a more complete mechanical description of the
process a theoretical Dart implementation could take.

To apply an augmentation to the main library:

1.  Merge the augmentation's declarations into the main library's top-level
    namespace using the following procedure.

1.  For each `import augment` directive in the augmentation library, in
    syntactic order:

    1.  Apply the imported augmentation to the main library using this
        procedure, recursively.

To merge a set of declarations `D` into a namespace:

1.  For each non-augmenting declaration in `D`:

    1.  If a declaration with that name already exists in the namespace, error.
        (Exception: setters do not collide with getters and final variables.)

    1.  Else, add the declaration to the namespace.

1.  For each augmenting declaration in `D`:

    1.  If the namespace does not have a declaration with that name, error.
        *A non-augmenting declaration must occur before it can be augmented.*

    1.  If the corresponding declaration in the namespace is not the same kind,
        error. "Kind" means class, mixin, function, etc. Getters, setters, and
        variables are all considered to have the same kind. In other words, you
        can't try to augment a class with a function or anything weird like
        that.

    1.  If the declaration is a class, mixin, enum, or extension:

        1.  Append the types in the augmentation's `implements` clause to the
            main type's clause.

        1.  Append the types in the augmentation's `on` clause to the main
            type's clause.

        1.  Append the types in the augmentation's `with` clause to the main
            type's clause.

        1.  Merge each instance member in the augmenting type into the instance
            namespace of the main type.

        1.  Merge each static member in the augmenting type into the static
            namespace of the main type.

    1.  Else, if the declaration is a function, getter, setter, or operator:

        1.  Replace the body of the main function with the augmenting function's
            body. Inside the augmenting body, a `super augment()`, `super
            augment`, `super augment =`, or `super augment <op>` expression as
            appropriate calls the original function body.

            **TODO: What is the syntax for calling a prefix operator's original
            code?**

    1.  Else, the declaration is a variable:

        1.  Replace a matching variable, getter, and/or setter in the namespace
            with the declaration. Inside the augmenting variable's initializer
            expression, an `augment super` expression invokes the original
            variable initializer.

## Deprecating part files

Part files have been [discouraged for many years][discourage]. They are still
fairly often used by code generators because it gives generated code access to
the main library's private namespace. However, it means that the generated part
file cannot have its own imports.

Augmentation libraries can do everything part files can do but also support
their own imports and can modify members. With these, we can more strongly
recommend the few users using them migrate to augmentations. In Dart 3.0, we can
consider removing support for part files entirely, which would simplify the
language and our tools.

## Changelog

### 1.7

*   Specify that augmentations must contain all the same keywords as the
    original declaration (and no more).

### 1.6

*   Allow class augmentations to use different names for type parameters. This
    isn't particular valuable, but is consistent with functions augmentations
    which are allowed to change the names of positional parameters.

*   Specify that a non-augmenting declaration must occur before any
    augmentations of it, in merge order.

*   Specify that augmentations can't have parts (#2057).

### 1.5

*   Augmentation libraries share the same top-level declaration and private
    scope with the main library and its other augmentations.

*   Now that enums have members, allow them to be augmented.

*   Compile-time error if a non-`late` augmenting instance variable calls the
    initializer for a `late` one.

### 1.4

*   When inferring the type of a variable, only the original variable's
    initializer is used.

### 1.3

*   Constructor and function augmentations can't define default values.

### 1.2

*   Specify that augmenting constructor initializers are inserted before the
    original constructor's super or redirecting initializer if present (#2062).
*   Specify that an augmenting type must replicate the original type's type
    parameters (#2058).
*   Allow augmenting declarations to add metadata annotations and macro
    applications (#2061).

### 1.1

*   Make it an error to apply the same augmentation multiple times (#1957).
*   Clarify type parameters and parameter modifiers in function signature
    matching (#2059).

### 1.0

Initial version.

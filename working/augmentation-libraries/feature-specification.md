# Augmentation Libraries

Author: rnystrom@google.com, jakemac@google.com
Version: 1.13 (see [Changelog](#Changelog) at end)

Augmentation libraries allow splitting a Dart library into files. Unlike part
files, each augmentation has its [own imports][part imports] and top-level
scope. Augmentations can add new top-level declarations, inject new members into
classes, and wrap functions and variables in additional code.

[part imports]: https://github.com/dart-lang/language/issues/519

## Motivation

Dart libraries are the unit of code reuse. When an API is too large to fit into
a single file, you can usually split it into multiple libraries and then have
one main library export the others. That works well when the functionality in
each file is made of separate top-level declarations.

However, sometimes a single *class* declaration is too large to fit comfortably
in a file. Dart libraries and even part files are no help there. Because of
this, users have asked for something like partial classes in C# ([#252][] 45 üëç,
[#678][] 15 üëç). C# also supports splitting [the declaration and implementation
of methods into separate files][partial].

[#252]: https://github.com/dart-lang/language/issues/252
[#678]: https://github.com/dart-lang/language/issues/678
[partial]: https://github.com/jaredpar/csharplang/blob/partial/proposals/extending-partial-methods.md

### Generated code

Size isn't the only reason to split a library into multiple files. Code
generation is common in Dart. [AngularDart][] compiles HTML templates to Dart
files. The [freezed][] and [built_value][] packages generate Dart code to
implement immutable data structures.

[angulardart]: https://github.com/angulardart
[freezed]: https://pub.dev/packages/freezed
[built_value]: https://pub.dev/packages/built_value

In cases like this, it's important to have the hand-authored and
machine-generated code in separate files so that the code generator doesn't
inadvertently erase a user's code. AngularDart generates a separate library for
the component. The freezed and built_value packages generate part files.

### Macros

The language team is investigating adding [macros][] to Dart. In theory, this
would *reduce* the need for text-based code generation language features.
Instead of code generation, users could write macros instead. They'd let the
compiler expand them, and not worry about anything ending up on disk.

[macros]: https://github.com/dart-lang/language/blob/master/working/macros/feature-specification.md

If users never needed to fix bugs in macros, look at stack traces, step into
code in a debugger, or navigate to the location of a compile error, that would
be true. But understanding and digging into code is fundamental to programming.
An error could be thrown from code generated by a macro. A macro might generate
code that produces a compile error (either deliberately because the macro was
misused or because the macro itself has a bug). A user might be profiling their
application and a macro might generate particularly slow code.

In all of those cases, users need some way to read and understand code produced
by macros. So, even if that code is generated automatically by the compiler as
part of macro expansion, it's still useful to have it be in a canonical
well-specified form that users can understand.

This proposal defines that format. The idea is that a Dart compiler executes
macros and then produces one or more augmentation library files that contain all
of the changes that the macros made to the library where they are applied. The
language then automatically merges those augmentations into the main library.

But augmentations aren't *only* a serialization format for macros. They are a
first-class language feature that can be produced by non-macro code generators
or written by hand by users who simply want to break a giant library or class
into smaller files.

## Augmentation libraries

An augmentation library is a separate file that *augments* another *main*
library. An augmentation is somewhere between a separate library and a part
file.

*   Like a library, it may contain all kinds of declarations&mdash;functions,
    classes, variables, etc.

*   Like a library, it has its own import scope and may contain its own imports.

*   Like a part file, all of the top-level declarations it produces end up in
    the top-level scope of the main library.

*   Like a part file, it shares a private scope with the main library and the
    two have mutual access to private declarations in the other file.

Augmentations have a few features unique to them:

*   An augmentation may add new members to existing types in the main library,
    including adding new values to enums.

*   A function in the augmentation may wrap the body of a function in the main
    library, or provide a body if none was present.

*   A variable in the augmentation may wrap the initializer of a variable in the
    main library, or provide an initializer if none was present.

*   An enum value in the augmentation may replace the argument list of an enum
    value in the main library, or provide an argument list if none was present.

These can't be expressed today using only imports, exports, and part files.

### Defining an augmentation

An augmentation has almost the same syntax and semantics as a normal Dart
library. Augmentations are distinguished by a special `library` directive with
an `augment` modifier, like so:

```dart
library augment 'main_library.dart';
```

**TODO: Better syntax? How does this interact with [import short-hand
syntax][import]?**

[import]: https://github.com/dart-lang/language/blob/master/working/0649%20-%20Import%20shorthand/proposal.md

The URL points to the main library that this augmentation is applied to.

After that, an augmentation library may contain anything a regular Dart library
can contain: imports, exports, classes, functions, constants, etc. All
augmentations of a main library share the same top level declaration scope.
Declarations in any augmentation or the main library are visible to all of the
others, including private ones.

However, augmentations do *not* share an import scope with the main library or
each other. The libraries one augmentation imports are visible only to that
file.

It is a compile-time error if:

*   A top-level declaration in an augmentation has the same name as a
    declaration in the main library or another of its augmentations (unless it
    is an *augmenting* declaration, described below). *This is the same error
    conceptually as having a name collision in one file.*

*   An augmentation library contains any `part` directives.

### Applying an augmentation library

A main library applies an augmentation to itself using a new import directive
that looks like this:

```dart
import augment 'some_augmentation.dart';
```

This directive tells the compiler to read the given library augmentation and
merge its declarations into this library. It is a compile-time error if:

*   The library referenced in an `import augment` directive is not an
    augmentation and does not have a `library augment` directive.

*   The library referenced in a `library augment` directive does not have an
    `import augment` directive pointing back to this augmentation.

*   The same augmentation library is applied more than once. *In other words,
    you can't have redundant `import augment` directives that point to the same
    library.*

*   The main library and its augmentations do not all have the same language
    version. There is only one user-visible library at the end, and it should
    have a consistent version across its entire surface area. *An augmentation
    library does not automatically inherit any language version from the main
    library and may need an explicit language version comment of its own in
    order to adhere to this requirement.*

Since the main library and its augmentation both point to each other, these
rules imply that a given augmentation file can only be used to augment a single
library.

### Merge order

A library may apply multiple augmentations to itself. Also, augmentation files
may themselves contain `import augment` directives. The entire tree of
augmentations is recursively applied to the main library. The merge order is
defined as a depth-first pre-order traversal of the `import augment` directives
starting at the main library.

Within a single augmentation library, you may augment the same declaration
multiple times, whether they are top level or nested declarations. The merge
order of these is defined as the source order of the augmentations.

For example:

```
// main.dart
import augment 'a.dart';
import augment 'c.dart';

class C {}

void trace() {
  print('main');
}

// a.dart
library augment 'main.dart';

import augment 'b.dart';

augment class C {}

augment void trace() {
  augmented();
  print('a');
}

// b.dart
library augment 'a.dart';

class D {}

augment void trace() {
  augmented();
  print('b');
}

// c.dart
library augment 'main.dart';

augment class D {}

augment void trace() {
  augmented();
  print('c');
}

augment void trace() {
  augmented();
  print('d');
}
```

The merge order is `main.dart`, `a.dart`, `b.dart`, then `c.dart`. The
declarations in those libraries&mdash;new declarations or augmentations&mdash;
are processed in that order, and source order within that.

This order is user-visible in two ways:

*   A non-augmenting declaration must appear first before it can be augmented.
    For example, `C` in `main.dart` is augmented by `C` in `a.dart`. Likewise,
    `D` in `b.dart` is augmented by `D` in `c.dart`. Note that the latter is
    allowed even though `b.dart` does not itself import `c.dart`.

*   When the same declaration is augmented multiple times, merge order
    determines the order that those wrappers are applied. When the `trace()`
    function is called, it prints:

    ```
    main
    a
    b
    c
    d
    ```

**TODO: Should it be a compile-time error if the main library and augmentation
are in different packages?**

## Augmenting declarations

Unlike part files, which can only add entirely new declarations, an augmentation
can also modify existing declarations in the main library. This can mean adding
new members to an existing type, or even modifying the code of an existing
declaration. There is a new built-in identifier, `augment`, which is used to
syntactically mark a declaration as an augmentation of an existing one. The
introduction of this new identifier will be language versioned in order to make
it non-breaking for old code.

It is also allowed for a non-abstract class to have abstract members, if those
members are filled in by an augmentation. This is primarily useful for macros,
which may be used to provide a body for an abstract member.

Often, an augmentation wants to also preserve and run the code of the original
declaration it augments (hence the name "augmentation"). It may want run before
the original code, after it, or both. To allow that, we allow a new expression
syntax inside the bodies of augmenting members. Inside a member marked
`augment`, the expression `augmented` can be used to refer to the original
function, getter, setter, or variable initializer. This is a contextual keyword
within `augment` members, and has no special meaning outside of that context.
See the next section for a full specification of what `augmented` actually
means, in the various contexts.

The same declaration can be augmented multiple times by separate augmentation
libraries. When that happens, the merge order defined previously determines
which order the wrapping is applied.

It is a compile-time error if:

*   An augmenting declaration has no corresponding original declaration to
    apply to.

*   An augmenting declaration appears in a library before the library where the
    original declaration occurs, according to merge order. *An augmentation
    library can both declare a new declaration and augment it in the same file.*

### Augmented Expression

The exact result of an `augmented` expression depends on what is being
augmented, but it follows generally the same rules as any normal identifier:

*   **Augmenting getters**: Within an augmenting getter `augmented` invokes the
    getter and evaluates to the return value. If augmenting a field with a
    getter, this will invoke the implicit getter from the augmented field.

*   **Augmenting setters**: Within an augmenting setter `augmented` must be
    followed by an `=` and will directly invoke the augmented setter. If
    augmenting a field with a setter, this will invoke the implicit setter from
    the augmented field.

*   **Augmenting fields**: Within an augmenting field, `augmented` can only be
    used in an initializer expression, and refers to the original field's
    initializer expression, which is immediately evaluated.

    It is a compile-time error to use `augmented` in an augmenting field's
    initializer if the member being augmented is not a field with an
    initializer.

*   **Augmenting functions**: When augmenting a function, `augmented` refers to
    the augmented function. Tear offs are not allowed, so this function must
    immediately be invoked.

*   **Augmenting operators**: When augmenting an operator, `augmented` must be
    followed by the operator. For example when augmenting `+` you must do
    `augmented + 1`, and when augmenting `[]` you must do `augmented[<arg>]`.
    These constructs invoke the augmented operator, and are the only valid uses
    of `augmented` in these contexts.

*   **Augmenting enum values**: When augmenting an enum value, `augmented` has
    no meaning and is not allowed.

In all relevant cases, if the augmented member is an instance member, it is
invoked with the same value for `this`.

### Augmenting types

A class, mixin, enum, or extension declaration can be marked with an `augment`
modifier:

```dart
augment class SomeClass {
  // ...
}
```

This means that instead of creating a new type declaration, the augmentation
modifies a corresponding declaration in the main library or one of its other
augmentations.

All the keywords (other than `augment`) must be identical between the original
declaration and the augmentation. This is to ensure that looking at either one
will give a complete depiction of the capabilities of the type, and an
augmentation cannot introduce hidden restrictions.

A class, enum, extension, or mixin augmentation may specify `extends`,
`implements`, `on`, and `with` clauses (when generally supported). The types in
these clauses are appended to the original declarations clauses of the same
kind, and if that clause did not exist previously then it is added with the new
types. All regular rules apply after this appending process, so you cannot have
multiple `extends` on a class, or an `on` clause on an enum, etc.

**TODO: Is appending the right order for mixins?**

Any instance or static members defined in the body of the type, including enum
values, are added to the instance or static namespace of the corresponding type
in the main library. In other words, the augmentation can add new members to an
existing type.

Instance and static members inside a type may themselves be augmentations. In
that case, they augment the corresponding members in the original type
declaration according to the rules in the following subsections.

It is a compile-time error if:

*   The augmenting type and corresponding type are not the same kind: class,
    mixin, enum, or extension. You can't augment a class with a mixin, etc.

*   The augmenting type and corresponding type do not have all the same
    modifiers (final, sealed, mixin, etc). This is not a technical requirement
    but it should make augmentations easier to understand when looking at them.

*   The augmenting type declares an `extends` clause, but one was already
    present. We don't allow overwriting an existing `extends`, but one can be
    filled in if it wasn't present originally.

*   An augmenting extension declares an `on` clause. We don't allow filling this
    in for extensions, it must on the original declaration. This restriction
    could be lifted later on if we have a compelling use case, as there is no
    fundamental reason it cannot be allowed, although it would be a parse error
    today to have an extension with no `on` clause.

*   The type parameters of the type augmentation do not match the original
    type's type parameters. This means there must be the same number of type
    parameters with the same bounds and names.

    *Since repeating the type parameters is, by definition, redundant, this
    doesn't accomplish anything semantically. But it ensures that anyone reading
    the augmenting type can see the declarations of any type parameters that it
    uses in its body and avoids potential confusion with other top-level
    variables that might be in scope in the augmentation library.*

### Augmenting functions

A top-level function, static method, instance method, or operator may be
augmented to wrap the original code in additional code:

```dart
// Wrap the original function in profiling:
augment int slowCalculation(int a, int b) {
  var watch = Stopwatch()..start();
  var result = augmented(a, b);
  print(watch.elapsedMilliseconds);
  return result;
}
```

The augmentation replaces the original function body with the augmenting code.
Inside the augmentation body, a special `augmented()` expression may be used to
execute the original function body. That expression takes an argument list
matching the original function's parameter list and returns the function's
return type.

The augmenting function does not have to pass the same arguments to
`augmented()` as were passed to it. It may call it once, more than once, or not
at all.

It is a compile-time error if:

*   The signature of the function augmentation does not exactly match the
    original function. This means the return types must be the same; there must
    be the same number of positional, optional, and named parameters; the types
    of corresponding positional and optional parameters must be the same; the
    names and types of named parameters must be the same; any type parameters
    and bounds must be the same; and any `required` or `covariant` modifiers
    must match.

    *Since repeating the signature is, by definition, redundant, this doesn't
    accomplish anything semantically. But it ensures that anyone reading the
    augmenting function can see the declarations of any parameters that it
    uses in its body.*

*   The function augmentation specifies any default values. *Default values are
    defined solely by the original function.*

**TODO: Should we allow augmenting functions to add parameters? If so, how does
this interact with type checking calls to the function?**

### Augmenting variables, getters, and setters

While the language treats variables, getters, and setters as
[mostly interchangeable][uniform], within augmentation libraries we do not allow
augmenting getters and setters with variables. Since augmentations are tightly
coupled to the libraries they augment, this restriction has minimal impact, and
it does not greatly affect the ability of a library to change a field to a
getter/setter pair or vice-versa.

[uniform]: https://en.wikipedia.org/wiki/Uniform_access_principle

You can think of variable, getter, and setter declarations all as ways to define
a higher-level "property" construct. A property has a name and a type. It may
have one or more other capabilities:

*   **A backing storage location.** You get this when you declare a variable.
    This also enables an instance variable to be assigned in a constructor
    initializer list. A variable may also have an **initializer** expression
    that gets run either lazily for top-level variables and static fields or at
    construction time when an instance is created.

*   **A getter function.** This function body is provided explicitly when you
    declare a getter. A variable declaration provides an implicit getter body
    that returns the value in the backing storage location. (Late variables do
    some additional checking in that implicit body.)

*   **A setter function.** A setter declaration provides this body explicitly. A
    non-final variable declaration provides an implicit setter body that stores
    the given value in the storage location. (Again, late variables do some
    additional checks.)

Declarations may be marked `abstract` or `external` and, if so, those are
mapped over to the corresponding getter and setter functions.

Augmentations on variables, getters, and setters works mostly at the level of
these separate capabilities. For example, augmenting a variable with a getter
replaces the variable's implicit getter body with the augmenting getter's.

More specifically:

*   **Augmenting with a getter:** A getter in an augmentation library can
    augment a getter in the main library or the implicit getter defined by a
    variable in the main library. Inside the augmenting body, an `augmented`
    expression invokes the original getter.

*   **Augmenting with a setter:** A setter in an augmentation library can
    augment a setter in the main library or the implicit setter defined by a
    non-final variable in the main library. Inside the augmenting setter, an
    `augmented =` expression invokes the original setter.

*   **Augmenting a getter and/or setter with a variable:** This is a
    compile-time error in all cases. Augmenting an abstract or external variable
    with a variable is also a compile-time error, as those are actually just
    syntax sugar for getter/setter pairs and do not have an initializer that you
    can augment.

    We may decide in the future to allow augmenting abstract or external
    getters, setters, or variables with variables, but for now you can instead
    use the following workaround:

    - Add a new field.
    - Augment the getter and/or setter to delegate to that field.

    If a non-abstract, non-external variable is augmented by a getter or setter,
    you **can** still augment the variable, as you are only augmenting the
    initializer of the original variable. This is not considered to be
    augmenting the augmenting getter or setter, since those are not actually
    altered.

    The reason for this compile time error is that whether a member declaration
    is a field versus a getter/setter is a visible property of the declaration:

    - It determines whether the member can be initialized in a constructor
      initializer list.
    - It is also a visible distinction when introspecting on a program with the
      analyzer, macros, or mirrors.

    When a declaration is augmented, we don't want the augmentation to be able
    to change any of the known properties of the existing member being
    augmented. For example, we don't allow you to augment a method with a getter
    that returns a function. Augmenting a getter/setter pair with a field would
    change the "can be used in a constructor initializer" property, so we forbid
    it. Augmenting a field with a getter/setter doesn't change that property so
    it is allowed.

*   **Augmenting a variable with a variable:** Augmenting a variable with a
    variable only alters its initializer. External and abstract variables cannot
    be augmented with variables, because they have no initializer to augment.

    Since the initializer is the only meaningful part of the augmenting
    declaration, an initializer must be provided. This augmenting initializer
    replaces the original initializer. The augmenting initializer may use an
    `augmented` expression which executes the original initializer expression
    when evaluated.

    The `late` property of a variable must always be consistent between the
    augmented variable and its augmenting variables.

    If the variable declaration in the original library does not have a type
    annotation, then the type is inferred only using the original library's
    initializer. (If there is no initializer in the original library, then the
    variable is inferred to have type `dynamic` like any non-augmented variable.
    *This ensures that augmenting a variable doesn't change its type. This is
    necessary to ensure that macros running after signatures are known can't
    change the signature of a declaration.*

It is a compile-time error if:

*   The original and augmenting declarations do not have the same type.

*   An augmenting declaration uses `augmented` when the original declaration has
    no concrete implementation. Note that all external declarations are assumed
    to have an implementation provided by another external source, and they will
    throw a runtime exception when called if not.

*   An augmenting initializer uses `augmented` and the augmented variable is not
    a variable with an initializer.

*   A final variable is augmented with a setter. (Instead, the augmentation
    library can declare a *non-augmenting* setter that goes alongside the
    implicit getter defined by the final variable.)

*   A non-final variable is augmented with a final variable. We don't want to
    leave the original setter in a weird state.

*  A `late` variable is augmented with a non-`late` variable.

*  A non-`late` variable is augmented with a `late` variable.

*  A getter or setter are augmented by a variable.

*  An abstract or external variable are augmented by a variable.

### Augmenting enum values

Enum values can _only_ be augmented by enum values, and the implicit getter
introduced by them is not augmentable. The one thing you are allowed to do is to
replace the argument list. There is no way to refer to the original argument
list (although a macro may be able introspect on it and copy over some or all of
the arguments).

An augmenting enum value is allowed to invoke a different constructor than
the original enum value, or provide an argument list where none was present
before.

New enum values may also be defined in the augmenting library, and they will
be appended to the original values in source and augmentation traversal order.
Augmenting an existing enum value never changes the order in which it appears in
`values`.

For example:

```
// main.dart
import augment 'a.dart';
import augment 'c.dart';

enum A {
  first;
}

// a.dart
library augment 'main.dart';

import augment 'b.dart';

augment enum A {
  second;
  augment first; // This is still `first` in values.
}
// b.dart
library augment 'a.dart';

augment enum A {
  augment third;
}

// c.dart
library augment 'main.dart';

augment enum A {
  augment fourth;
}
```

Then `A.values` is `[A.first, A.second, A.third, A.fourth]`.

It is a compile-time error if:

*   An augmenting getter is defined for an enum value.

### Augmenting constructors

Constructors are (as always) more complex. A constructor marked `augment`
replaces the body of the corresponding constructor in the main library with its
body. If the augmenting constructor has any initializers, they are appended to
the original constructor's initializers, but before any original super
initializer or original redirecting initializer if there is one.

In the augmenting constructor's body, an `augmented()` call invokes the
original constructor's body.

It is a compile-time error if:

*   The signature of the constructor augmentation does not match the original
    constructor. This means the return types must be the same; there must be the
    same number of positional, optional, and named parameters; the types of
    corresponding positional and optional parameters must be the same; the names
    and types of named parameters must be the same; any type parameters and
    bounds must be the same; and any `required` or `covariant` modifiers must
    match. Any initializing formals must be the same in both constructors.

    **TODO: Is this the right way to handle initializing formals?**

*   The constructor augmentation specifies any default values. *Default values
    are defined solely by the original constructor.*

*   The original constructor is `const` and the augmenting constructor is not
    or vice versa.

*   The original constructor is a factory constructor and the augmenting
    constructor has an initializer list.

*   The original constructor has a super initializer or redirecting initializer
    and the augmenting constructor does too.

**TODO: What about redirecting constructors?**

### Augmenting external members

When augmenting an `external` member, it is assumed that a real implementation
of that member has already been filled by some tool prior to any augmentations
being applied. Thus, it is allowed to use `augmented` from augmenting members
on external declarations, but it may throw a `noSuchMethod` error at runtime if
no implementation was in fact provided.

**NOTE**: Macros should _not_ be able to statically tell if an external body has
been filled in by a compiler, because it could lead to a different result on
different platforms or tools.

**TODO: Should we add a syntax to let the augmentation dynamically detect
whether there is an external implementation to call?**

### Metadata annotations and macro applications

An augmentation declaration may have metadata annotations or macro applications.
These are appended to the list of metadata annotations and macro applications on
the original declaration.

## Scoping

Like part files, the main library and all of its augmentations share a single
top-level scope where declarations are defined. They also share a single private
namespace. This means that private declarations in the main library or an
augmentation are visible to all augmentations.

Unlike part files, an augmentation library has its own import scope surrounding
that shared top-level scope. Any libraries the augmentation imports are visible
only to that augmentation library. Likewise, libraries imported by the main
library are not implicitly imported by the augmentation.

Exports in an augmentation library are applied to the main library and become
exports from the main library's namespace.

The static and instance member namespaces for an augmented type are shared
across the declaration of the type in the main library and all augmentations of
that type. Identifiers in the bodies of members (both implicit ones and explicit
uses like `this.` or `TypeName.`) are resolved against that complete merged
namespace. For example:

```dart
// Main library "some_lib.dart":
import augment 'some_augment.dart';

import 'other_lib.dart';

const a = 1;

class C {
  bool isEven(int n) {
    if (n == 0) return true;
    return !_isOdd(n - 1);
  }
}

// Augmentation "some_augment.dart":
library augment 'some_lib.dart';

import 'also_lib.dart';

const b = 2;

augment class C {
  bool _isOdd(int n) => !isEven(n - 1);
}
```

This code is fine. Code in C in the main library can refer to members added in
the augmentation library like `_isOdd()`. Meanwhile, code in the augmentation
can see members like `isEven()` declared in the main library.

You can visualize the namespace nesting sort of like this:

```
some_lib.dart       | some_augment.dart
                    |
.-----------------. | .-----------------.
| import scope:   | | | import scope:   |
| other_lib       | | | also_lib        |
'-----------------' | '-----------------'
         ^          |         ^
         |          |         |
.--------------------------------------.
| top-level declaration scope:         |
| const a                              |
| class C                              |
| const b                              |
'--------------------------------------'
         ^          |         ^
         |          |         |
.--------------------------------------.
| class C instance members:            |
| isEven()                             |
| _isOdd()                             |
'--------------------------------------'
         ^          |         ^
         |          |         |
.-----------------. | .-----------------.
| C.isEven() body | | | C._isOdd() body |
'-----------------' | '-----------------'
```

Each library has its own namespace chain from its own member bodies out to its
own import namespace. But in the middle, each passes through the shared class
namespaces for the instance and static members and the shared top level
declaration scope.

This implies that the bodies of members cannot be resolved until after
augmentations have been merged. We don't know what namespace `isEven()` or
`_isOdd()` will be found in until the namespace for the class has had *all*
augmentations merged in.

Fortunately, augmentations can be applied purely syntactically. In order to
merge augmentations into the main library, we only need to match declarations
by name. So a Dart compiler can theoretically:

1.  Parse the main library and all of its augmentations.
2.  Merge the augmentations to determine the complete set of declarations in
    all types.
3.  Resolve and type-check the main library and all of its augmentations now
    that all type namespaces are complete.

## Syntax

The grammar changes are fairly simple. A main library can apply an augmentation
using a new directive:

```
importOrExport ::= libraryImport
  | libraryAugmentImport
  | libraryExport

libraryAugmentImport ::= metadata 'import' 'augment' uri ';'
```

A library directive may contain `augment` followed by a URI to denote the file
as an augmentation library:

```
libraryName ::= metadata 'library'
    ( dottedIdentifierList | 'augment' uri ) ';'
```

In an augmentation library, the grammar is slightly modified to allow an
`augment` modifier before various declarations:

```
topLevelDeclaration ::= classDeclaration
  | mixinDeclaration
  | extensionDeclaration
  | enumType
  | typeAlias
  | 'external' functionSignature ';'
  | 'external' getterSignature ';'
  | 'external' setterSignature ';'
  | 'augment'? functionSignature functionBody
  | 'augment'? getterSignature functionBody
  | 'augment'? setterSignature functionBody
  | 'augment'? ('final' | 'const') type? staticFinalDeclarationList ';'
  | 'augment'? 'late' 'final' type? initializedIdentifierList ';'
  | 'augment'? 'late'? varOrType initializedIdentifierList ';'

classDeclaration ::=
  'augment'? 'abstract'? 'class' identifier typeParameters?
  // Rest of rule...

mixinDeclaration ::= 'augment'? 'mixin' identifier typeParameters?
  // Rest of rule...

classMemberDeclaration ::= declaration ';'
  | 'augment'? methodSignature functionBody

declaration ::= 'external' factoryConstructorSignature
  | 'external' constantConstructorSignature
  | 'external' constructorSignature
  | ('external' 'static'?)? getterSignature
  | ('external' 'static'?)? setterSignature
  | ('external' 'static'?)? functionSignature
  | 'external'? operatorSignature
  | 'augment'? 'static' 'const' type? staticFinalDeclarationList
  | 'augment'? 'static' 'final' type? staticFinalDeclarationList
  | 'augment'? 'static' 'late' 'final' type? initializedIdentifierList
  | 'augment'? 'static' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'covariant' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'late'? 'final' type? initializedIdentifierList
  | 'augment'? 'late'? varOrType initializedIdentifierList
  | 'augment'? redirectingFactoryConstructorSignature
  | 'augment'? constantConstructorSignature (redirection | initializers)?
  | 'augment'? constructorSignature (redirection | initializers)?
```

**TODO: Define the grammar for the various `augmented` expressions.**

It is a compile-time error if:

*   A function, getter, setter, or operator declaration marked `augment` is also
    abstract.

*   A declaration marked `augment` is also marked `external`.

## Static semantics

Previous sections informally describe the process of applying augmentations to
the main library, but here's a more complete mechanical description of the
process a theoretical Dart implementation could take.

To apply an augmentation to the main library:

1.  Merge the augmentation's declarations into the main library's top-level
    namespace using the following procedure.

1.  For each `import augment` directive in the augmentation library, in
    syntactic order:

    1.  Apply the imported augmentation to the main library using this
        procedure, recursively.

To merge a set of declarations `D` into a namespace:

1.  For each non-augmenting declaration in `D`:

    1.  If a declaration with that name already exists in the namespace, error.
        (Exception: setters do not collide with getters and final variables.)

    1.  Else, add the declaration to the namespace.

1.  For each augmenting declaration in `D`:

    1.  If the namespace does not have a declaration with that name, error.
        *A non-augmenting declaration must occur before it can be augmented.*

    1.  If the corresponding declaration in the namespace is not the same kind,
        error. "Kind" means class, mixin, function, etc. Getters, setters, and
        variables are all considered to have the same kind. In other words, you
        can't try to augment a class with a function or anything weird like
        that.

    1.  If the declaration is a class, mixin, enum, or extension:

        1.  Append the types in the augmentation's `implements` clause to the
            main type's clause.

        1.  Append the types in the augmentation's `on` clause to the main
            type's clause.

        1.  Append the types in the augmentation's `with` clause to the main
            type's clause.

        1.  Merge each instance member in the augmenting type into the instance
            namespace of the main type.

        1.  Merge each static member in the augmenting type into the static
            namespace of the main type.

    1.  Else, if the declaration is a function, getter, setter, or operator:

        1.  Replace the body of the main function with the augmenting function's
            body. Inside the augmenting body, a `super augment()`, `super
            augment`, `super augment =`, or `super augment <op>` expression as
            appropriate calls the original function body.

            **TODO: What is the syntax for calling a prefix operator's original
            code?**

    1.  Else, the declaration is a variable:

        1.  Replace a matching variable, getter, and/or setter in the namespace
            with the declaration. Inside the augmenting variable's initializer
            expression, an `augmented` expression invokes the original variable
            initializer.

## Documentation comments

Documentation comments are allowed in all the standard places in augmentation
libraries. It is up to the tooling to decide how to present such documentation
comments to the user, but they should generally be considered to be additive,
and should not completely override the original comment. In other words, it is
not the expectation that augmentations should duplicate the original
documentation comments, but instead provide comments that are specific to the
augmentation.

## Deprecating part files

Part files have been [discouraged for many years][discourage]. They are still
fairly often used by code generators because it gives generated code access to
the main library's private namespace. However, it means that the generated part
file cannot have its own imports.

Augmentation libraries can do everything part files can do but also support
their own imports and can modify members. With these, we can more strongly
recommend the few users using them migrate to augmentations. In Dart 3.0, we can
consider removing support for part files entirely, which would simplify the
language and our tools.

## Changelog

## 1.14

*   Change `augment super` to `augmented`.

## 1.13

*   Clarify which clauses are (not) allowed in augmentations of certain
    declarations.
*   Allow adding an `extends` clause in augmentations.

## 1.12

*   Update the behavior for variable augmentations.

## 1.11

*   Alter and clarify the semantics around augmenting external declarations.
*   Allow non-abstract classes to have implictly abstract members which are
    implemented in an augmentation.

## 1.10

*   Make `augment` a built-in identifier.

### 1.9

*   Specify that documentation comments are allowed, and should be considered to
    be additive and not a complete override of the original comment. The rest of
    the behavior is left up to implementations and not specified.

### 1.8

*   Specify that main libraries and thier augmentations must have the same
    language version.

*   Specifically call out that augmentations can add and augment enum values,
    and specify how that works.

### 1.7

*   Specify that augmentations must contain all the same keywords as the
    original declaration (and no more).

### 1.6

*   Allow class augmentations to use different names for type parameters. This
    isn't particular valuable, but is consistent with functions augmentations
    which are allowed to change the names of positional parameters.

*   Specify that a non-augmenting declaration must occur before any
    augmentations of it, in merge order.

*   Specify that augmentations can't have parts (#2057).

### 1.5

*   Augmentation libraries share the same top-level declaration and private
    scope with the main library and its other augmentations.

*   Now that enums have members, allow them to be augmented.

*   Compile-time error if a non-`late` augmenting instance variable calls the
    initializer for a `late` one.

### 1.4

*   When inferring the type of a variable, only the original variable's
    initializer is used.

### 1.3

*   Constructor and function augmentations can't define default values.

### 1.2

*   Specify that augmenting constructor initializers are inserted before the
    original constructor's super or redirecting initializer if present (#2062).
*   Specify that an augmenting type must replicate the original type's type
    parameters (#2058).
*   Allow augmenting declarations to add metadata annotations and macro
    applications (#2061).

### 1.1

*   Make it an error to apply the same augmentation multiple times (#1957).
*   Clarify type parameters and parameter modifiers in function signature
    matching (#2059).

### 1.0

Initial version.

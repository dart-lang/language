# Augmentations

Author: rnystrom@google.com, jakemac@google.com
Version: 1.15 (see [Changelog](#Changelog) at end)

Augmentations allow spreading your implementation across multiple locations,
both within a single file and across multiple files. They can add new top-level
declarations, inject new members into classes, and wrap functions and variables
in additional code.

## Motivation

Dart libraries are the unit of code reuse. When an API is too large to fit into
a single file, you can usually split it into multiple libraries and then have
one main library export the others. That works well when the functionality in
each file is made of separate top-level declarations.

However, sometimes a single *class* declaration is too large to fit comfortably
in a file. Dart libraries and even part files are no help there. Because of
this, users have asked for something like partial classes in C# ([#252][] 71 üëç,
[#678][] 18 üëç). C# also supports splitting [the declaration and implementation
of methods into separate files][partial].

[#252]: https://github.com/dart-lang/language/issues/252
[#678]: https://github.com/dart-lang/language/issues/678
[partial]: https://github.com/jaredpar/csharplang/blob/partial/proposals/extending-partial-methods.md

### Generated code

Size isn't the only reason to split a library into multiple files. Code
generation is common in Dart. [AngularDart][] compiles HTML templates to Dart
files. The [freezed][] and [built_value][] packages generate Dart code to
implement immutable data structures.

[angulardart]: https://github.com/angulardart
[freezed]: https://pub.dev/packages/freezed
[built_value]: https://pub.dev/packages/built_value

In cases like this, it's important to have the hand-authored and
machine-generated code in separate files so that the code generator doesn't
inadvertently erase a user's code. AngularDart generates a separate library for
the component. The freezed and built_value packages generate part files.

### Macros

The language team is investigating adding [macros][] to Dart. In theory, this
would *reduce* the need for text-based code generation language features.
Instead of code generation, users could write macros instead. They'd let the
compiler expand them, and not worry about anything ending up on disk.

[macros]: https://github.com/dart-lang/language/blob/master/working/macros/feature-specification.md

If users never needed to fix bugs in macros, look at stack traces, step into
code in a debugger, or navigate to the location of a compile error, that would
be true. But understanding and digging into code is fundamental to programming.
An error could be thrown from code generated by a macro. A macro might generate
code that produces a compile error (either deliberately because the macro was
misused or because the macro itself has a bug). A user might be profiling their
application and a macro might generate particularly slow code.

In all of those cases, users need some way to read and understand code produced
by macros. So, even if that code is generated automatically by the compiler as
part of macro expansion, it's still useful to have it be in a canonical
well-specified form that users can understand.

This proposal defines that format. The idea is that a Dart compiler executes
macros and then produces one or more library augmentation files that contain all
of the changes that the macros made to the library where they are applied. The
language then automatically merges those library augmentations into the
augmented library.

But library augmentations aren't *only* a serialization format for macros. They
are a first-class language feature that can be produced by non-macro code
generators or written by hand by users who simply want to break a giant library
or class into smaller files.

## Library Augmentations

A library augmentation is a separate file that *augments* an existing library,
referred to as the *augmented* library. A library augmentation is similar to
but more powerful than a part file, and it is not a library in its own right.

*   Like a library, it may contain all kinds of declarations&mdash;functions,
    classes, variables, etc.

*   Like a library, it has its own import scope and may contain its own imports.

*   Like a part file, all of the top-level declarations it produces end up in
    the top-level scope of the augmented library.

*   Like a part file, it shares a private scope with the augmented library and
    the two have mutual access to private declarations in the other file.

Library augmentations may also contain declaration augmentations, which augment
existing declarations from the library. Some examples include:

*   Type augmentations, which can add new members to types, including adding new
    values to enums, or even alter the type hierarchy by adding mixins, etc.

*   Function augmentations, which can replace the body of a function, or provide
    a body if none was present.

*   Variable augmentations, which can wrap the initializer of a variable in the
    augmented library, or provide an initializer if none was present.

These can't be expressed today using only imports, exports, and part files.

### Defining a library augmentation

A library augmentation has almost the same syntax and semantics as a normal
Dart library. They are distinguished by a special `library` directive with
an `augment` modifier, like so:

```dart
augment library 'main_library.dart';
```

**TODO: Better syntax? How does this interact with [import short-hand
syntax][import]?**

[import]: https://github.com/dart-lang/language/blob/master/working/0649%20-%20Import%20shorthand/proposal.md

The URI points to the URI of the file which includes this library augmentation
via an `import augment <uri>;`.

After that, an augmentation may contain anything a regular Dart library can
contain: imports, exports, classes, functions, constants, etc. All
augmentations of an augmented library share the same top level declaration
scope. Declarations in any library augmentation or the augmented library are
visible to all of the others, including private ones.

However, library augmentations do *not* share an import scope with the augmented
library or each other. The libraries one library augmentation imports are
visible only to that file.

It is a compile-time error if:

*   A top-level declaration in a library augmentation has the same name as a
    declaration in the augmented library or another of its library augmentations
    (unless it is a declaration augmentation, described below). *This is the
    same error conceptually as having a name collision in one file.*

*   An augmentation contains any `part` directives.

*   A library augmentation contains a normal `library` directive. They are not
    self-contained libraries, only pieces of the augmented library.

*   An `import augment` directive has a `<uri>` that denotes an entity which
    is not a library augmentation. *For example, it can not be a library.*

*   An `export` or `import` (not `import augment`) refers to an entity which
    is not a library. *For example, it cannot be a library augmentation or
    a part file.*

*   There is a cycle in the graph whose edges are the `import augment`
    directives of an augmented library and of any augmentation libraries which
    are directly or indirectly reachable from there via said edges.

### Applying an augmentation

A library applies an augmentation to itself using a new import directive with
the `augment` modifier, which looks like this:

```dart
import augment 'some_augmentation.dart';
```

This directive tells the compiler to read the given library augmentation and
merge its declarations into the augmented library. It is a compile-time error
if:

*   The URI referenced in an `import augment` directive is not a library
    augmentation.

*   The URI referenced in an `augment library` directive does not have an
    `import augment` directive pointing back to this augmentation.

*   The same library augmentation is applied more than once. *In other words,
    you can't have redundant `augment` directives that point to the same file.*.

*   The augmented library and its library augmentations do not all have the same
    language version. There is only one library, and it should have a consistent
    language version across its entire surface area. *A library augmentation
    does not automatically inherit any language version from the augmented
    library and may need an explicit language version comment of its own in order
    to adhere to this requirement.*

Since the augmented library and its library augmentations both point to each
other, these rules imply that a given library augmentation can only be used to
augment a single library.

### Merge order

A library may apply multiple library augmentations to itself. Also, library
augmentations may themselves contain `import augment` directives. The entire
tree of library augmentations is recursively applied to the augmented library.
The merge order is defined as a depth-first pre-order traversal of the library
augmentations, in the source order of their `import augment` directives.

Within a single library augmentation, you may augment the same declaration
multiple times, whether it is a top level or nested declaration. The merge
order is defined as the source order of the declaration augmentations.

For example:

```
// main.dart
import augment 'a.dart';
import augment 'c.dart';

class C {}

void trace() {
  print('main');
}

// a.dart
augment library 'main.dart';

import augment 'b.dart';

augment class C {}

augment void trace() {
  augmented();
  print('a');
}

// b.dart
augment library 'a.dart';

class D {}

augment void trace() {
  augmented();
  print('b');
}

// c.dart
augment library 'main.dart';

augment class D {}

augment void trace() {
  augmented();
  print('c');
}

augment void trace() {
  augmented();
  print('d');
}
```

The merge order is `main.dart`, `a.dart`, `b.dart`, then `c.dart`. The
declarations in those library augmentations
&mdash;new declarations or augmentations&mdash; are processed in that order,
and source order within that.

This order is user-visible in two ways:

*   A regular (i.e. non-augmenting) declaration must appear first before it can
    be augmented. For example, `C` in `main.dart` is augmented by `C` in
    `a.dart`. Likewise, `D` in `b.dart` is augmented by `D` in `c.dart`. Note
    that the latter is allowed even though `b.dart` does not itself import
    `c.dart`.

*   When the same declaration is augmented multiple times, merge order
    determines the order that those wrappers are applied. When the `trace()`
    function is called, it prints:

    ```
    main
    a
    b
    c
    d
    ```

**TODO: Should it be a compile-time error if the augmented library and
library augmentation are in different packages?**

## Augmenting declarations

Unlike part files, which can only add entirely new declarations, a library
augmentation can also modify existing declarations in the augmented library.
This can mean adding new members to an existing type, or even modifying the code
of an existing declaration. There is a new built-in identifier, `augment`, which
is used to syntactically mark a declaration as an augmentation of an existing
one. The introduction of this new identifier will be language versioned in order
to make it non-breaking for old code.

It is also allowed for a non-abstract class to have abstract members, if those
members are filled in by an augmentation. This is primarily useful for macros,
which may be used to provide a body for an abstract member.

Often, an augmentation wants to also preserve and run the code of the original
declaration it augments (hence the name "augmentation"). It may want run before
the original code, after it, or both. To allow that, we allow a new expression
syntax inside the bodies of augmenting members. Inside a member marked
`augment`, the expression `augmented` can be used to refer to the original
function, getter, setter, or variable initializer. This is a contextual keyword
within `augment` members, and has no special meaning outside of that context.
See the next section for a full specification of what `augmented` actually
means, in the various contexts.

The same declaration can be augmented multiple times by separate library
augmentations. When that happens, the merge order defined previously determines
which order the wrapping is applied.

It is a compile-time error if:

*   An augmenting declaration has no corresponding original declaration to
    apply to.

*   An augmenting declaration appears in a library before the library where the
    original declaration occurs, according to merge order. *An library
    augmentation can both declare a new declaration and augment it in the same
    file.*

### Augmented Expression

The exact result of an `augmented` expression depends on what is being
augmented, but it follows generally the same rules as any normal identifier:

*   **Augmenting getters**: Within an augmenting getter `augmented` invokes the
    getter and evaluates to the return value. If augmenting a field with a
    getter, this will invoke the implicit getter from the augmented field.

*   **Augmenting setters**: Within an augmenting setter `augmented` must be
    followed by an `=` and will directly invoke the augmented setter. If
    augmenting a field with a setter, this will invoke the implicit setter from
    the augmented field.

*   **Augmenting fields**: Within an augmenting field, `augmented` can only be
    used in an initializer expression, and refers to the original field's
    initializer expression, which is immediately evaluated.

    It is a compile-time error to use `augmented` in an augmenting field's
    initializer if the member being augmented is not a field with an
    initializer.

*   **Augmenting functions**: When augmenting a function, `augmented` refers to
    the augmented function. Tear offs are not allowed, so this function must
    immediately be invoked.

*   **Augmenting operators**: When augmenting an operator, `augmented` must be
    followed by the operator. For example when augmenting `+` you must do
    `augmented + 1`, and when augmenting `[]` you must do `augmented[<arg>]`.
    These constructs invoke the augmented operator, and are the only valid uses
    of `augmented` in these contexts.

*   **Augmenting enum values**: When augmenting an enum value, `augmented` has
    no meaning and is not allowed.

In all relevant cases, if the augmented member is an instance member, it is
invoked with the same value for `this`.

### Augmenting types

A class, enum, extension, extension type, or mixin declaration can be marked
with an `augment` modifier:

```dart
augment class SomeClass {
  // ...
}
```

This means that instead of creating a new declaration, the augmentation modifies
a corresponding declaration in the augmented library or one of its other
augmentations.

A class, enum, extension type, or mixin augmentation may specify `extends`,
`implements`, `on`, and `with` clauses (when generally supported). The types
in these clauses are appended to the original declarations clauses of the same
kind, and if that clause did not exist previously then it is added with
the new types. All regular rules apply after this appending process, so you
cannot have multiple `extends` on a class, or an `on` clause on an enum, etc.

Instance or static members defined in the body of the type, including enum
values, are added to the instance or static namespace of the corresponding type
in the augmented library. In other words, the augmentation can add new members
to an existing type.

Instance and static members inside a type may themselves be augmentations. In
that case, they augment the corresponding members in the original type
declaration according to the rules in the following subsections.

It is a compile-time error if:

*   The augmenting type and corresponding type are not the same kind: class,
    mixin, enum, extension, or extension type. You can't augment a class with a
    mixin, etc.

*   The augmenting type and corresponding type do not have all the same
    modifiers (`abstract`, `base`, `final`, `interface`, `sealed`, and `mixin`
    when it occurs immediately before `class`).

    *This is not a technical requirement, but it ensures that looking at either
    declaration show the complete capabilities of the declaration. It also
    deliberately prevents an augmentation from introducing a restriction that
    isn't visible to a reader of the main declaration.*

*   The augmenting type declares an `extends` clause, but one was already
    present. We don't allow overwriting an existing `extends`, but one can be
    filled in if it wasn't present originally.

*   An augmenting extension declares an `on` clause. We don't allow filling this
    in for extensions, it must be on the original declaration. This restriction
    could be lifted later if we have a compelling use case, as there is no
    fundamental reason it cannot be allowed, although it would be a parse error
    today to have an extension with no `on` clause.

*   The type parameters of the type augmentation do not match the original
    type's type parameters. This means there must be the same number of type
    parameters with the same bounds and names.

    *Since repeating the type parameters is, by definition, redundant, this
    doesn't accomplish anything semantically. But it ensures that anyone reading
    the augmenting type can see the declarations of any type parameters that it
    uses in its body and avoids potential confusion with other top-level
    variables that might be in scope in the library augmentation.*

### Augmenting functions

A top-level function, static method, instance method, or operator may be
augmented to wrap the original code in additional code:

```dart
// Wrap the original function in profiling:
augment int slowCalculation(int a, int b) {
  var watch = Stopwatch()..start();
  var result = augmented(a, b);
  print(watch.elapsedMilliseconds);
  return result;
}
```

The augmentation replaces the original function body with the augmenting code.
Inside the augmentation body, a special `augmented()` expression may be used to
execute the original function body. That expression takes an argument list
matching the original function's parameter list and returns the function's
return type.

The augmenting function does not have to pass the same arguments to
`augmented()` as were passed to it. It may call it once, more than once, or not
at all.

It is a compile-time error if:

*   The signature of the function augmentation does not exactly match the
    original function. This means the return types must be the same; there must
    be the same number of positional, optional, and named parameters; the types
    of corresponding positional and optional parameters must be the same; the
    names and types of named parameters must be the same; any type parameters
    and bounds must be the same; and any `required` or `covariant` modifiers
    must match.

    *Since repeating the signature is, by definition, redundant, this doesn't
    accomplish anything semantically. But it ensures that anyone reading the
    augmenting function can see the declarations of any parameters that it
    uses in its body.*

*   The function augmentation specifies any default values. *Default values are
    defined solely by the original function.*

**TODO: Should we allow augmenting functions to add parameters? If so, how does
this interact with type checking calls to the function?**

### Augmenting variables, getters, and setters

While the language treats variables, getters, and setters as
[mostly interchangeable][uniform], within augmentations we do not allow
augmenting getters and setters with variables. Since augmentations are tightly
coupled to the libraries they augment, this restriction has minimal impact, and
it does not greatly affect the ability of a library to change a field to a
getter/setter pair or vice-versa.

[uniform]: https://en.wikipedia.org/wiki/Uniform_access_principle

You can think of variable, getter, and setter declarations all as ways to define
a higher-level "property" construct. A property has a name and a type. It may
have one or more other capabilities:

*   **A backing storage location.** You get this when you declare a variable.
    This also enables an instance variable to be assigned in a constructor
    initializer list. A variable may also have an **initializer** expression
    that gets run either lazily for top-level variables and static fields or at
    construction time when an instance is created.

*   **A getter function.** This function body is provided explicitly when you
    declare a getter. A variable declaration provides an implicit getter body
    that returns the value in the backing storage location. (Late variables do
    some additional checking in that implicit body.)

*   **A setter function.** A setter declaration provides this body explicitly. A
    non-final variable declaration provides an implicit setter body that stores
    the given value in the storage location. (Again, late variables do some
    additional checks.)

Declarations may be marked `abstract` or `external` and, if so, those are
mapped over to the corresponding getter and setter functions.

Augmentations on variables, getters, and setters works mostly at the level of
these separate capabilities. For example, augmenting a variable with a getter
replaces the variable's implicit getter body with the augmenting getter's.

More specifically:

*   **Augmenting with a getter:** A getter in an augmentation can augment a
    getter in the library or the implicit getter defined by a variable in the
    library. Inside the augmenting body, an `augmented` expression invokes the
    original getter.

*   **Augmenting with a setter:** A setter in an augmentation can augment a
    setter in the library or the implicit setter defined by a non-final variable
    in the library. Inside the augmenting setter, an `augmented =` expression
    invokes the original setter.

*   **Augmenting a getter and/or setter with a variable:** This is a
    compile-time error in all cases. Augmenting an abstract or external variable
    with a variable is also a compile-time error, as those are actually just
    syntax sugar for getter/setter pairs and do not have an initializer that you
    can augment.

    We may decide in the future to allow augmenting abstract or external
    getters, setters, or variables with variables, but for now you can instead
    use the following workaround:

    - Add a new field.
    - Augment the getter and/or setter to delegate to that field.

    If a non-abstract, non-external variable is augmented by a getter or setter,
    you **can** still augment the variable, as you are only augmenting the
    initializer of the original variable. This is not considered to be
    augmenting the augmenting getter or setter, since those are not actually
    altered.

    The reason for this compile time error is that whether a member declaration
    is a field versus a getter/setter is a visible property of the declaration:

    - It determines whether the member can be initialized in a constructor
      initializer list.
    - It is also a visible distinction when introspecting on a program with the
      analyzer, macros, or mirrors.

    When a declaration is augmented, we don't want the augmentation to be able
    to change any of the known properties of the existing member being
    augmented. For example, we don't allow you to augment a method with a getter
    that returns a function. Augmenting a getter/setter pair with a field would
    change the "can be used in a constructor initializer" property, so we forbid
    it. Augmenting a field with a getter/setter doesn't change that property so
    it is allowed.

*   **Augmenting a variable with a variable:** Augmenting a variable with a
    variable only alters its initializer. External and abstract variables cannot
    be augmented with variables, because they have no initializer to augment.

    Since the initializer is the only meaningful part of the augmenting
    declaration, an initializer must be provided. This augmenting initializer
    replaces the original initializer. The augmenting initializer may use an
    `augmented` expression which executes the original initializer expression
    when evaluated.

    The `late` property of a variable must always be consistent between the
    augmented variable and its augmenting variables.

    If the variable declaration in the original library does not have a type
    annotation, then the type is inferred only using the original library's
    initializer. (If there is no initializer in the original library, then the
    variable is inferred to have type `dynamic` like any non-augmented variable.
    *This ensures that augmenting a variable doesn't change its type. This is
    necessary to ensure that macros running after signatures are known can't
    change the signature of a declaration.*

It is a compile-time error if:

*   The original and augmenting declarations do not have the same type.

*   An augmenting declaration uses `augmented` when the original declaration has
    no concrete implementation. Note that all external declarations are assumed
    to have an implementation provided by another external source, and they will
    throw a runtime exception when called if not.

*   An augmenting initializer uses `augmented` and the augmented variable is not
    a variable with an initializer.

*   A final variable is augmented with a setter. (Instead, the augmentation
    can declare a *non-augmenting* setter that goes alongside the implicit
    getter defined by the final variable.)

*   A non-final variable is augmented with a final variable. We don't want to
    leave the original setter in a weird state.

*  A `late` variable is augmented with a non-`late` variable.

*  A non-`late` variable is augmented with a `late` variable.

*  A getter or setter are augmented by a variable.

*  An abstract or external variable are augmented by a variable.

### Augmenting enum values

Enum values can _only_ be augmented by enum values, and the implicit getter
introduced by them is not augmentable. The one thing you are allowed to do is to
replace the argument list. There is no way to refer to the original argument
list (although a macro may be able introspect on it and copy over some or all of
the arguments).

An augmenting enum value is allowed to invoke a different constructor than
the original enum value, or provide an argument list where none was present
before.

New enum values may also be defined in the augmentation, and they will be
appended to the original values in augmentation traversal order. Augmenting an
existing enum value never changes the order in which it appears in `values`.

For example:

```
// main.dart
import augment 'a.dart';
import augment 'c.dart';

enum A {
  first;
}

// a.dart
augment library 'main.dart';

import augment 'b.dart';

augment enum A {
  second;
  augment first; // This is still `first` in values.
}

// b.dart
augment library 'a.dart';

augment enum A {
  augment third;
}

// c.dart
augment library 'main.dart';

augment enum A {
  augment fourth;
}
```

Then `A.values` is `[A.first, A.second, A.third, A.fourth]`.

It is a compile-time error if:

*   An augmenting getter is defined for an enum value.

### Augmenting constructors

Constructors are (as always) more complex. A constructor marked `augment`
replaces the body of the existing constructor with its body. If the augmenting
constructor has any initializers, they are appended to the original
constructor's initializers, but before any original super initializer or
original redirecting initializer if there is one.

In the augmenting constructor's body, an `augmented()` call invokes the
original constructor's body.

It is a compile-time error if:

*   The signature of the constructor augmentation does not match the original
    constructor. This means the return types must be the same; there must be the
    same number of positional, optional, and named parameters; the types of
    corresponding positional and optional parameters must be the same; the names
    and types of named parameters must be the same; any type parameters and
    bounds must be the same; and any `required` or `covariant` modifiers must
    match. Any initializing formals must be the same in both constructors.

    **TODO: Is this the right way to handle initializing formals?**

*   The constructor augmentation specifies any default values. *Default values
    are defined solely by the original constructor.*

*   The original constructor is `const` and the augmenting constructor is not
    or vice versa.

*   The original constructor is a factory constructor and the augmenting
    constructor has an initializer list.

*   The original constructor has a super initializer or redirecting initializer
    and the augmenting constructor does too.

**TODO: What about redirecting constructors?**

When augmenting an extension type declaration, the parenthesized clause where
the representation type is specified is treated as a constructor that has a
single positional parameter, a single initializer from the parameter to the
representation field, and an empty body.

This means that an augmentation can add a body to an extension type's
constructor, which isn't otherwise possible. *(But note that there is no
guarantee that any instance of an extension type will have necessarily executed
that body, since you can get instances of extension types through casts or other
conversions that sidestep the constructor.)*

*This is designed in anticipation of supporting [primary constructors][] on
other types in which case the extension type syntax will then be understood by
users to be a primary constructor for the extension type.*

[primary constructors]:
https://github.com/dart-lang/language/blob/main/working/2364%20-%20primary%20constructors/feature-specification.md

### Augmenting external members

When augmenting an `external` member, it is assumed that a real implementation
of that member has already been filled by some tool prior to any augmentations
being applied. Thus, it is allowed to use `augmented` from augmenting members
on external declarations, but it may throw a `noSuchMethod` error at runtime if
no implementation was in fact provided.

**NOTE**: Macros should _not_ be able to statically tell if an external body has
been filled in by a compiler, because it could lead to a different result on
different platforms or tools.

**TODO: Should we add a syntax to let the augmentation dynamically detect
whether there is an external implementation to call?**

### Metadata annotations and macro applications

An augmentation declaration may have metadata annotations or macro applications.
These are appended to the list of metadata annotations and macro applications on
the original declaration.

## Scoping

Like part files, the augmented library and all of its library augmentations
share a single top-level scope where declarations are defined. They also share a
single private namespace. This means that private declarations in the augmented
library or an augmentation of it are visible to all augmentations.

Unlike part files, a library augmentation has its own import scope surrounding
that shared top-level scope. Any libraries the augmentation imports are visible
only to that library augmentation. Likewise, libraries imported by the augmented
library are not implicitly imported by the library augmentation.

Exports in a library augmentation are applied to the augmented library and
become exports from the augmented library's namespace.

The static and instance member namespaces for an augmented type are shared
across the declaration of the type in the augmented library and all
augmentations of that type. Identifiers in the bodies of members (both implicit
ones and explicit uses like `this.` or `TypeName.`) are resolved against that
complete merged namespace. For example:

```dart
// Main library "some_lib.dart":
import 'other_lib.dart';

import augment 'some_augment.dart';

const a = 1;

class C {
  bool isEven(int n) {
    if (n == 0) return true;
    return !_isOdd(n - 1);
  }
}

// Augmentation "some_augment.dart":
augment library 'some_lib.dart';

import 'also_lib.dart';

const b = 2;

augment class C {
  bool _isOdd(int n) => !isEven(n - 1);
}
```

This code is fine. Code in C in the augmented library can refer to members added
in the augmentation like `_isOdd()`. Meanwhile, code in the augmentation can see
members like `isEven()` declared in the augmented library.

You can visualize the namespace nesting sort of like this:

```
some_lib.dart       | some_augment.dart
                    |
.-----------------. | .-----------------.
| import scope:   | | | import scope:   |
| other_lib       | | | also_lib        |
'-----------------' | '-----------------'
         ^          |         ^
         |          |         |
.--------------------------------------.
| top-level declaration scope:         |
| const a                              |
| class C                              |
| const b                              |
'--------------------------------------'
         ^          |         ^
         |          |         |
.--------------------------------------.
| class C instance members:            |
| isEven()                             |
| _isOdd()                             |
'--------------------------------------'
         ^          |         ^
         |          |         |
.-----------------. | .-----------------.
| C.isEven() body | | | C._isOdd() body |
'-----------------' | '-----------------'
```

Each library augmentation has its own namespace chain from its own member bodies
out to its own import namespace. But in the middle, each passes through the
shared class namespaces for the instance and static members and the shared top
level declaration scope.

This implies that the bodies of members cannot be resolved until after
augmentations have been merged. We don't know what namespace `isEven()` or
`_isOdd()` will be found in until the namespace for the class has had *all*
augmentations merged in.

Fortunately, augmentations can be applied purely syntactically. In order to
merge augmentations into the augmented library, we only need to match
declarations by name. So a Dart compiler can theoretically:

1.  Parse the augmented library and all of its augmentations.
2.  Merge the augmentations to determine the complete set of declarations in
    all types.
3.  Resolve and type-check the augmented library and all of its augmentations
    now that all type namespaces are complete.

## Syntax

The grammar changes are fairly simple. A library can apply an augmentation using
a new directive:

```
importOrExport ::= libraryImport
  | libraryAugmentImport
  | libraryExport

libraryAugmentImport ::= metadata 'import' 'augment' uri ';'
```

A library directive may contain `augment` followed by a URI to denote the file
as an augmentation:

TODO: Create special augmentation grammar, similar to library/part files?

```
libraryName ::= metadata libraryNameBody ';'

libraryNameBody ::= 'library' dottedIdentifierList?
  | 'augment' 'library' uri
```

In an augmentation, the grammar is slightly modified to allow an `augment`
modifier before various declarations:

```
topLevelDeclaration ::= classDeclaration
  | mixinDeclaration
  | extensionTypeDeclaration
  | extensionDeclaration
  | enumType
  | typeAlias
  | 'external' functionSignature ';'
  | 'external' getterSignature ';'
  | 'external' setterSignature ';'
  | 'external' finalVarOrType identifierList ';'
  | 'augment'? functionSignature functionBody
  | 'augment'? getterSignature functionBody
  | 'augment'? setterSignature functionBody
  | 'augment'? ('final' | 'const') type? staticFinalDeclarationList ';'
  | 'augment'? 'late' 'final' type? initializedIdentifierList ';'
  | 'augment'? 'late'? varOrType initializedIdentifierList ';'

classDeclaration ::= 'augment'? (classModifiers | mixinClassModifiers)
    'class' typeWithParameters superclass? interfaces?
    '{' (metadata classMemberDeclaration)* '}'
  | 'augment'? classModifiers 'mixin'? 'class' mixinApplicationClass

mixinDeclaration ::= 'augment'? 'base'? 'mixin' typeIdentifier
  typeParameters? ('on' typeNotVoidNotFunctionList)? interfaces?
  '{' (metadata mixinMemberDeclaration)* '}'

extensionDeclaration ::= 'augment'? 'extension' typeIdentifierNotType?
  typeParameters? 'on' type
  '{' (metadata classMemberDeclaration)* '}'

extensionTypeDeclaration ::= 'augment'? 'extension' 'type' 'const'? typeIdentifier
  typeParameters? representationDeclaration interfaces?
  '{' (metadata classMemberDeclaration)* '}'

enumType ::= 'augment'? 'enum' typeIdentifier
  typeParameters? mixins? interfaces?
  '{' enumEntry (',' enumEntry)* (',')?
  (';' (metadata classMemberDeclaration)*)? '}'

typeAlias ::= 'augment'? 'typedef' typeIdentifier typeParameters? '=' type ';'
  | 'augment'? 'typedef' functionTypeAlias

classMemberDeclaration ::= declaration ';'
  | 'augment'? methodSignature functionBody

declaration ::= 'external' factoryConstructorSignature
  | 'external' constantConstructorSignature
  | 'external' constructorSignature
  | ('external' 'static'?)? getterSignature
  | ('external' 'static'?)? setterSignature
  | ('external' 'static'?)? functionSignature
  | 'external' ('static'? finalVarOrType | 'covariant' varOrType) identifierList
  | 'external'? operatorSignature
  | 'abstract' (finalVarOrType | 'covariant' varOrType) identifierList
  | 'augment'? 'static' 'const' type? staticFinalDeclarationList
  | 'augment'? 'static' 'final' type? staticFinalDeclarationList
  | 'augment'? 'static' 'late' 'final' type? initializedIdentifierList
  | 'augment'? 'static' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'covariant' 'late' 'final' type? identifierList
  | 'augment'? 'covariant' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'late'? 'final' type? initializedIdentifierList
  | 'augment'? 'late'? varOrType initializedIdentifierList
  | 'augment'? redirectingFactoryConstructorSignature
  | 'augment'? constantConstructorSignature (redirection | initializers)?
  | 'augment'? constructorSignature (redirection | initializers)?
```

**TODO: Define the grammar for the various `augmented` expressions.**

It is a compile-time error if:

*   A function, getter, setter, or operator declaration marked `augment` is also
    abstract.

*   A declaration marked `augment` is also marked `external`.

## Static semantics

Previous sections informally describe the process of applying augmentations to
the augmented library, but here's a more complete mechanical description of the
process a theoretical Dart implementation could take.

To apply a library augmentation to the augmented library:

1.  Merge the augmentation's declarations into the augmented library's
    top-level namespace using the procedure below.

1.  For each `import augment` directive in the augmentation, in syntactic order:

    1.  Apply the augmentation to the augmented library using this procedure,
        recursively.

To merge a set of declarations `D` into a namespace:

1.  For each non-augmenting declaration in `D`:

    1.  If a declaration with that name already exists in the namespace, error.
        (Exception: setters do not collide with getters and final variables.)

    1.  Else, add the declaration to the namespace.

1.  For each augmenting declaration in `D`:

    1.  If the namespace does not have a declaration with that name, error.
        *A regular declaration must occur before it can be augmented.*

    1.  If the corresponding declaration in the namespace is not the same kind,
        error. "Kind" means class, mixin, function, etc. Getters, setters, and
        variables are all considered to have the same kind. In other words, you
        can't try to augment a class with a function or anything weird like
        that.

    1.  If the declaration is a class, mixin, enum, or extension:

        1.  Append the types in the augmentation's `implements` clause to the
            augmented type's `implements` clause.

        1.  Append the types in the augmentation's `on` clause to the augmented
            type's `on` clause.

        1.  Append the types in the augmentation's `with` clause to the
            augmented type's `with` clause.

        1.  Merge each instance member in the augmenting type into the instance
            namespace of the augmented type.

        1.  Merge each static member in the augmenting type into the static
            namespace of the augmented type.

    1.  Else, if the declaration is a function, getter, setter, or operator:

        1.  Replace the body of the augmented function with the augmenting
            function's body. Inside the augmenting body, an `augmented()`,
            `augmented`, `augmented =`, or `augmented <op>` expression as
            appropriate calls the augmented function body.

            **TODO: What is the syntax for calling a prefix operator's original
            code?**

    1.  Else, the declaration is a variable:

        1.  Replace a matching variable, getter, and/or setter in the namespace
            with the declaration. Inside the augmenting variable's initializer
            expression, an `augmented` expression invokes the original variable
            initializer.

## Documentation comments

Documentation comments are allowed in all the standard places in library
augmentations. It is up to the tooling to decide how to present such
documentation comments to the user, but they should generally be considered to
be additive, and should not completely override the original comment. In other
words, it is not the expectation that augmentations should duplicate the
original documentation comments, but instead provide comments that are specific
to the augmentation.

## Deprecating part files

Part files have been [discouraged for many years][discourage]. They are still
fairly often used by code generators because it gives generated code access to
the main library's private namespace. However, it means that the generated part
file cannot have its own imports.

Library augmentation can do everything part files can do but also support their
own imports and can modify members. With these, we can more strongly recommend
the few users using them migrate to library augmentations. In Dart 4.0, we can
consider removing support for part files entirely, which would simplify the
language and our tools.

## Changelog

## 1.17

*   Introduce compile-time errors about wrong structures in the graph of
    libraries and augmentation libraries formed by directives like `import`
    and `import augment` (#3646).

## 1.16

*   Update grammar rules and add support for augmented type declarations of
    all kinds (class, mixin, extension, extension type, enum, typedef).

*   Specify augmenting extension types. Clarify that primary constructors
    (which currently only exist for extension types) can be augmented like
    other constructors (#3177).

## 1.15

*   Change `libary augment` to `augment library`.

## 1.14

*   Change `augment super` to `augmented`.

## 1.13

*   Clarify which clauses are (not) allowed in augmentations of certain
    declarations.
*   Allow adding an `extends` clause in augmentations.

## 1.12

*   Update the behavior for variable augmentations.

## 1.11

*   Alter and clarify the semantics around augmenting external declarations.
*   Allow non-abstract classes to have implictly abstract members which are
    implemented in an augmentation.

## 1.10

*   Make `augment` a built-in identifier.

### 1.9

*   Specify that documentation comments are allowed, and should be considered to
    be additive and not a complete override of the original comment. The rest of
    the behavior is left up to implementations and not specified.

### 1.8

*   Specify that augmented libraries and thier augmentations must have the same
    language version.

*   Specifically call out that augmentations can add and augment enum values,
    and specify how that works.

### 1.7

*   Specify that augmentations must contain all the same keywords as the
    original declaration (and no more).

### 1.6

*   Allow class augmentations to use different names for type parameters. This
    isn't particular valuable, but is consistent with functions augmentations
    which are allowed to change the names of positional parameters.

*   Specify that a non-augmenting declaration must occur before any
    augmentations of it, in merge order.

*   Specify that augmentations can't have parts (#2057).

### 1.5

*   Augmentation libraries share the same top-level declaration and private
    scope with the augmented library and its other augmentations.

*   Now that enums have members, allow them to be augmented.

*   Compile-time error if a non-`late` augmenting instance variable calls the
    initializer for a `late` one.

### 1.4

*   When inferring the type of a variable, only the original variable's
    initializer is used.

### 1.3

*   Constructor and function augmentations can't define default values.

### 1.2

*   Specify that augmenting constructor initializers are inserted before the
    original constructor's super or redirecting initializer if present (#2062).
*   Specify that an augmenting type must replicate the original type's type
    parameters (#2058).
*   Allow augmenting declarations to add metadata annotations and macro
    applications (#2061).

### 1.1

*   Make it an error to apply the same augmentation multiple times (#1957).
*   Clarify type parameters and parameter modifiers in function signature
    matching (#2059).

### 1.0

Initial version.

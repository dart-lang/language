# Augmentations

Author: rnystrom@google.com, jakemac@google.com, lrn@google.com <br>
Version: 1.21 (see [Changelog](#Changelog) at end)

Augmentations allow spreading your implementation across multiple locations,
both within a single file and across multiple files. They can add new top-level
declarations, inject new members into classes, and wrap functions and variables
in additional code.

## Motivation

Dart libraries are the unit of code reuse. When an API is too large to fit into
a single file, you can usually split it into multiple libraries and then have
one main library export the others. That works well when the functionality in
each file is made of separate top-level declarations.

However, sometimes a single *class* declaration is too large to fit comfortably
in a file. Dart libraries and even part files are no help there. Because of
this, users have asked for something like partial classes in C# ([#252][] 71 üëç,
[#678][] 18 üëç). C# also supports splitting [the declaration and implementation
of methods into separate files][partial].

[#252]: https://github.com/dart-lang/language/issues/252
[#678]: https://github.com/dart-lang/language/issues/678
[partial]: https://github.com/jaredpar/csharplang/blob/partial/proposals/extending-partial-methods.md

### Generated code

Size isn't the only reason to split a library into multiple files. Code
generation is common in Dart. [AngularDart][] compiles HTML templates to Dart
files. The [freezed][] and [built_value][] packages generate Dart code to
implement immutable data structures.

[angulardart]: https://github.com/angulardart
[freezed]: https://pub.dev/packages/freezed
[built_value]: https://pub.dev/packages/built_value

In cases like this, it's important to have the hand-authored and
machine-generated code in separate files so that the code generator doesn't
inadvertently erase a user's code. AngularDart generates a separate library for
the component. The freezed and built_value packages generate part files.

### Macros

The language team is investigating adding [macros][] to Dart. In theory, this
would *reduce* the need for text-based code generation language features.
Instead of code generation, users could write macros instead. They'd let the
compiler expand them, and not worry about anything ending up on disk.

[macros]: https://github.com/dart-lang/language/blob/master/working/macros/feature-specification.md

If users never needed to fix bugs in macros, look at stack traces, step into
code in a debugger, or navigate to the location of a compile error, that would
be true. But understanding and digging into code is fundamental to programming.
An error could be thrown from code generated by a macro. A macro might generate
code that produces a compile error (either deliberately because the macro was
misused or because the macro itself has a bug). A user might be profiling their
application and a macro might generate particularly slow code.

In all of those cases, users need some way to read and understand code produced
by macros. So, even if that code is generated automatically by the compiler as
part of macro expansion, it's still useful to have it be in a canonical
well-specified form that users can understand.

This proposal defines that format. The idea is that a Dart compiler executes
macros and then produces one or more new part files that contain all
of the changes that the macros made to the library where they are applied, as
new declarations to be added or augmentations that modify existing
declarations. The compiler then adds those part files to the existing libraries.

But improved part files and augmenting declarations are not *only* a
serialization format for macros. They are first-class language features that
can be produced by non-macro code generators or written by hand by users who
simply want to break a giant library or class into smaller files.

## Part files with imports

As part of the meta-programming and augmentation features, we expand the
capabilities of part files. See [‚ÄúParts with Imports‚Äù][parts_with_imports.md].

With that feature, a part file can now have its own `import` and `export`
directives, and further nested `part` files, with part files inheriting the
imports and prefixes of their parent (part or library) file.

Augmentation declarations interact with part files mainly in restrictions on
where an augmenting declaration may occur relative to the declaration it
augments, as describe below.

For this, we define the following relations on *declarations* based on the
relations between *files* of a library.

We say that a syntactic declaration *occurs in* a Dart file if the
declaration‚Äôs source code occurs in that Dart file.

We then say that a Dart file *contains* a declaration if the declaration occurs
in the file itself, or if any of the files included by the Dart file contains
the declaration. _That is, if the declaration occurs in a file in the sub-tree
of that Dart file._

We then define a partial and a complete *ordering* of declarations of a library
as follows:

We define a partial ordering on syntactic declarations of a library,
*is above*, such that a syntactic declaration *A* is *above* a syntactic
declaration *B* if and only if:

*   *A* and *B* occur in the same file, and the start of the *A* declaration is
syntactically before the start of the *B* declaration, in source order, or
*   A file included by the file containing *A* contains *B*.

We define a *total ordering relation* (transitive, anti-symmetric, irreflexive)
on declarations of a library, *is before* (and its reverse, *is after*) such
that for any two syntactic declarations *A*, and *B*:

*   If *A* and *B* occur in the same file, then:
    *   If the start of *A* is before the start of *B* in source order,
        then *A* is before *B*.
    *   Otherwise *B* is before *A*.
*   Otherwise *A* and *B* occur in different files.
*   Let *F* be the least containing file for those two files.
*   If *A* occurs in *F* then *A* is before *B*.
*   If *B* occurs in *F* then *B* is before *A*.
*   Otherwise *A* and *B* are contained in distinct included files of *F*.
*   If the `part` directive including the file that contains *A*
    is syntactically before the `part` directive including the file that
    contains *B* in source order, then *A* is before *B*.
*   Otherwise *B* is before *A*.

Then *B* *is after* *A* if and only if *A* *is before* *B*.

(Here the first five points can be summarized as ‚ÄúIf *A* is above *B*, then *A*
is before *B*, and vice versa‚Äù and the remaining case covers when the two are
contained in sibling part directives, and at least one of those three cases
must occur.)

This order is total. It‚Äôs effectively ordering declarations as by a pre-order
depth-first traversal of the file-tree, visiting declarations of a file in
source order, and then recursing on `part`-directives in source order.

[parts_with_imports.md]: parts_with_imports.md "Parts with Imports Feature Specification"

## Augmentation declarations

Augmentation declarations are declarations marked with the new built-in
identifier `augment`, which makes the declaration augment an existing
declaration, which is itself a normal declaration with zero or more prior
augmentations applied. An augmentation declaration does not  introduce a new
name into the surrounding scope, it attaches itself to the existing name.

Making `augment`  a built-in identifier is language versioned, to make it
non-breaking for pre-feature code.

Augmentation declarations include:

*   Type augmentations, which can add new members to types, including adding new
    values to enums, or even alter the type hierarchy by adding mixin
    applications to a class.

*   Function augmentations, which can replace the body of a function, or provide
    a body if none was present.

*   Variable augmentations, which can wrap the initializer of a variable in the
    augmented library, or provide an initializer if none was present.

These operations cannot be expressed today using only imports, exports, or part
files. Any Dart file (library file or part file) can contain augmentation
declarations.

An augmentation declaration can add new members to an existing type, or even
modify the code of an existing declaration.

Because of augmentations, non-abstract class (or similar) declarations are now
allowed to contain abstract member declarations, as long as those
members are filled in by an augmentation declaration. _This is primarily useful
for macros, which may be used to provide a body for an abstract member._

An augmentation that replaces the body of a function, may also want to preserve
and run the code of the original declaration that it augments (hence the name
"augmentation"). It may want to run its own code before the original code,
after it, or both. To support that, we allow a new expression syntax inside the
‚Äúbodies‚Äù of augmenting declarations (function bodies, constructor bodies, and
variable initializers). Inside an expression of a member marked
`augment`, the identifier `augmented` can be used to refer to the original
function, getter, or setter body, or variable initializer. This is a contextual
keyword
within `augment` members, and has no special meaning outside of that context.
See the next section for a full specification of what `augmented` means, and
how it must be used, in the various contexts.

The same declaration can be augmented multiple times by separate augmentation
declarations. When that happens, the *augmentation application order* defines
in which order the augmentations are applied, with later augmentations applying
to the result of applying all earlier augmentations to the original base
declaration. The augmentation application order is defined rather simply,
because of a further requirement on where augmentations of the same declaration
can occur relative to each other.

It‚Äôs a **compile-time error** if a library contains an augmentation
declaration, but no non-augmentation declaration with the corresponding name in
the same scope. _(A mutable variable declaration counts as having both a getter
and a setter name.)_

For the following, we‚Äôll say that one declaration of a library is *above*
another declaration of the same library if and only if:

*   The former declaration is in the same file as the latter declaration, and it
    is textually earlier in the file (‚Äúabove‚Äù in the source code as normally
    presented), or
*   The former declaration is in a file that is a direct or transitive parent
    file of the file of the latter declaration (‚Äúabove‚Äù in the file tree
    hierarchy).

We can similarly define *below* as the inverse of that relation. Both *before*
and *after* define *strict partial orders* on declarations in a library.

It‚Äôs a **compile-time error** if a library contains an augmentation declaration
and a corresponding non-augmentation base declaration, and the base
declaration is not *above* the augmentation declaration.

These requirements ensure that declarations that contribute to the same
effective declaration, one base declaration and zero or more augmentation
declarations, are *totally ordered* by the *above* relation, with the base
declaration at the top, and the declarations all being in files on a single
*path* down the file tree.

The *augmentation application order* for a single base declaration‚Äôs (validly
positioned) augmentation declarations is then in *before* order: An augmentation
declaration is applied after any augmentation declarations that are *before* it,
and before augmentation declarations that it is before.

This applies both to top-level declarations and to member declarations of, for
example, class declarations.

#### Path requirement lint suggestion

One issue with the augmentation application order is that it is not stable
under reordering of `part` directives. Sorting part directives can change the
order that augmentation applications in separate included sub-trees are applied
in.

To help avoiding issues, we want to introduce a *lint* which warns if a library
is susceptible to part file reordering changing augmentation application order.
A possible name could be `augmentation_ordering`.

It‚Äôs effect would be to **report a warning** *if* for any two (top-level)
augmenting declarations with name *n*, one is not *above* the other.

The lint would only apply to user-written augmenting declarations, it should
not include macro generated augmentations. Those are placed where the macro
processor chooses to place them, usually after all other augmentations.

If the lint is satisfied, then all augmenting declarations are ordered by the
*before* relation, which means that they no two can be in different sibling
parts of the same file, and therefore all the augmenting declarations occur
along a single path down the part-file tree. _That ensures that
*part file directive ordering* has no effect on augmentation application order._

The language specification doesn‚Äôt specify lints or warnings, so this lint
suggestion is not normative. We wish to have the lint, and preferably include
it in the ‚Äúrecommended‚Äù lint set, because it can help users avoid accidental
problems. We want it as a lint instead of a language restriction so that it
doesn‚Äôt interfere with macro-generated code, and so that users can `// ignore:`
it if they know what they‚Äôre doing.

### Augmented Expression

The exact result of an `augmented` expression depends on what is being
augmented, but it generally follows the same rules as any normal identifier:

*   **Augmenting getters**: Within an augmenting getter `augmented` invokes the
    getter and evaluates to the return value. If augmenting a field with a
    getter, this will invoke the implicit getter from the augmented field.

*   **Augmenting setters**: Within an augmenting setter `augmented` must be
    followed by an `=` and will directly invoke the augmented setter. If
    augmenting a field with a setter, this will invoke the implicit setter from
    the augmented field.

*   **Augmenting fields**: Within an augmenting field, `augmented` can only be
    used in an initializer expression, and refers to the original field's
    initializer expression, which is immediately evaluated.

    It is a compile-time error to use `augmented` in an augmenting field's
    initializer if the member being augmented is not a field with an
    initializer.

*   **Augmenting functions**: When augmenting a function, `augmented` refers to
    the augmented function. Tear offs are not allowed, so this function must
    immediately be invoked.

*   **Augmenting operators**: When augmenting an operator, `augmented` must be
    followed by the operator. For example when augmenting `+` you must do
    `augmented + 1`, and when augmenting `[]` you must do `augmented[<arg>]`.
    These constructs invoke the augmented operator, and are the only valid uses
    of `augmented` in these contexts.

*   **Augmenting enum values**: When augmenting an enum value, `augmented` has
    no meaning and is not allowed.

In all relevant cases, if the augmented member is an instance member, it is
invoked with the same value for `this`.

Assume that the identifier `augmented` occurs such that the outermost
enclosing declaration is not an augmenting declaration. In this case, the
identifier is taken to be a reference to a declaration which is in scope.

*In other words, `augmented` is just a normal identifier when it occurs
anywhere other than inside an augmented declaration.*

*Note that, for example, `augmented()` is an invocation of the augmented
function or method when it occurs in an augmenting function or method
declaration. (In the latter case, the augmenting method declaration must
occur inside an augmenting type-introducing declaration, e.g., an
augmenting class or mixin declaration). This is also true if `augmented()`
occurs inside a local function declaration inside the body of that function
or method declaration. We could say that `augmented` is a contextual
keyword because it is unable to refer to a declaration in scope when it
occurs inside an augmenting declaration, it always has the special meaning
which is associated with augmentations.*

A compile-time error occurs if a declaration with the name `augmented`
occurs in a location where the outermost enclosing declaration is
augmenting. *This error is applicable to all such declarations, e.g.,
local functions, local variables, parameters, and type parameters.*

A compile-time error occurs if `augmented` occurs in a non-augmenting
declaration, of a kind that can be augmenting, inside an augmenting
declaration.

*For example, inside `augment class C` we could have a declaration like
`void f() {...augmented()...}`.
This is an error because the outer `augment` forces the meaning of `augmented`
to be about augmentation in the entire scope, but the method declaration is an
introduction, not an augmentation.*

### Augmenting types

A class, enum, extension, extension type, or mixin declaration can be marked
with an `augment` modifier:

```dart
augment class SomeClass {
  // ...
}
```

This means that instead of creating a new declaration, the augmentation modifies
a corresponding declaration (above) in the library.

A class, enum, extension type, or mixin augmentation may specify `extends`,
`implements` and `with` clauses (when generally supported). The types
in these clauses are appended to the original declarations‚Äô clauses of the same
kind, and if that clause did not exist previously, then it is added with
the new types. All regular rules apply after this appending process, so you
cannot have multiple `extends` on a class, or an `on` clause on an enum, etc.

Instance or static members defined in the body of the augmenting type,
including enum values, are added to the instance or static namespace of the
corresponding type in the augmented library. In other words, the augmentation
can add new members to an existing type.

Instance and static members inside a type may themselves be augmentations. In
that case, they augment the corresponding members in augmented type
declaration (a based declaration and zero or more augmentations that are all
above the current augmenting type declaration) according to the rules in the
following subsections.

It is a **compile-time error** if:

*   The augmenting type and corresponding type are not the same kind: class,
    mixin, enum, extension, or extension type. You cannot augment a class with a
    mixin, etc.

*   The augmenting type and augmented type do not have all the same
    modifiers: `abstract`, `base`, `final`, `interface`, `sealed` and `mixin`
    for `class` declarations, and `base` for `mixin` declarations.

    *This is not a technical requirement, but it ensures that looking at either
    declaration shows the complete capabilities of the declaration. It also
    deliberately prevents an augmentation from introducing a restriction that
    isn't visible to a reader of the main declaration.*

*   The augmenting type declares an `extends` clause for a `class` declaration,
    but one was already
    present _(or the `class` was a `mixin class` declaration, which does not
    allow `extends` clauses)_. We do not allow overwriting an existing
    `extends`, but one can be filled in if if none had been specified.

*   The augmenting type declares an `extends` clause, but one was already
    present. We don't allow overwriting an existing `extends`, but one can be
    filled in if it wasn't present originally.

*   An augmenting extension declares an `on` clause. We don't allow replacing
    this in for `extension` declarations, and the `on` clause is required on
    the original declaration, so an `augment extension` cannot have any `on`
    clause. We also do not allow adding further restrictions to a `mixin`
    declaration, so no further types can be added to its `on` clause, if it
    even has one. These restrictions could both be lifted later if we have a
    compelling use case, as there is no fundamental reason it cannot be
    allowed. It is a parse error today to have an `extension` declaration with
    no `on` clause.

*   The type parameters of the augmenting type do not match the original
    type's type parameters. This means there must be the same number of type
    parameters with the exact same type parameter names (same identifiers) and
    bounds (same *types*, even if they may not be written exactly the same in
    case one of the declarations needs to refer to a type using an import
    prefix).

    *Since repeating the type parameters is, by definition, redundant, this
    restriction doesn't accomplish anything semantically. It ensures that
    anyone reading
    the augmenting type can see the declarations of any type parameters that it
    uses in its body and avoids potential confusion with other top-level
    variables that might be in scope in the library augmentation.*

### Augmenting functions

A top-level function, static method, instance method, or operator may be
augmented to replace or wrap the original body code in additional code:

```dart
// Wrap the original function in profiling:
augment int slowCalculation(int a, int b) {
  var watch = Stopwatch()..start();
  var result = augmented(a, b);
  print(watch.elapsedMilliseconds);
  return result;
}
```

The augmentation replaces the augmented function‚Äôs body with the augmenting
function‚Äôs body.
Inside the augmenting function‚Äôs body, a special `augmented(‚Ä¶)` expression may
be used to execute the original function body. That expression takes an
argument list matching the original function's parameter list and returns the
function's return type.

The augmenting function does not have to pass the same arguments to
`augmented(‚Ä¶)` as were passed to it. It may invoke `augmented` once, more than
once, or not at all.

It is a compile-time error if:

*   The function signature of the augmenting function does not exactly match the
    function signature of the augmented function. This means the return types
    must be the same type; there must be same number or required and optional
    positional parameters, all with the  same types, the sane number of named
    parameters, each pairwise with the same name, same type and same `required`
    and `covariant` modifiers, and any type parameters and their bounds must be
    the same (like for type declarations).

    *Since repeating the signature is, by definition, redundant, this doesn't
    accomplish anything semantically. But it ensures that anyone reading the
    augmenting function can see the declarations of any parameters that it
    uses in its body.*

*   The augmenting function specifies any default values. *Default values are
    defined solely by the original function.*

*   An augmenting declaration uses `augmented` when the original declaration has
    no concrete implementation. Note that all external declarations are assumed
    to have an implementation provided by another external source, and they will
    throw a runtime exception when called if not.

**TODO: Should we allow augmenting functions to add optional parameters? If so,
how does this interact with type checking calls to the function?**

**TODO: Should we allow an augmenting function to repeat default values? Or
change default values? Invoking the `augmented` function should will supply the
original default values for omitted arguments.**

### Augmenting variables, getters, and setters

While the language treats variables, getters, and setters as
[mostly interchangeable][uniform], within augmentations we do not allow
augmenting getters and setters with variables. Since augmentations are tightly
coupled to the libraries they augment, this restriction has minimal impact, and
it does not greatly affect the ability of a library to change a field to a
getter/setter pair or vice-versa.

[uniform]: https://en.wikipedia.org/wiki/Uniform_access_principle

You can think of variable, getter, and setter declarations all as ways to define
a higher-level "property" construct. A property has a name and a type. It may
have one or more other capabilities:

*   **A backing storage location.** You get this when you declare a
    non-`external` variable.
    Having a storage location enables (and often requires) having the variable
    initialized by generative constructors. A variable may also have an
    **initializer** expression that gets run either lazily for top-level and
    static variables or at object construction/initialization time for instance
    variables.

*   **A getter function.** This function‚Äôs body is provided explicitly when you
    declare a getter. A variable declaration provides an implicit getter body
    that returns the value in the backing storage location. (Late variables do
    some additional checking in that implicit body.)

*   **A setter function.** A setter declaration provides a body explicitly. A
    non-final variable declaration provides an implicit setter body that stores
    the given value in the storage location. (Again, late variables do some
    additional updates and/or checks.)

Declarations may be marked `abstract` or `external` and, if so, those are
mapped over to the corresponding getter and setter functions. An `abstract`
variable declaration is equivalent to an abstract getter declaration, and if
not `final`, also an abstract setter declaration. An `external` variable
similarly define an `external` getter and possibly an `external` setter, but
unlike abstract declarations, these are a valid implementations of the
signature.

Augmentations on variables, getters, and setters works mostly at the level of
these separate capabilities. For example, augmenting a variable with a getter
replaces the augmented variable's implicit getter body with the augmenting
getter's.

More specifically:

*   **Augmenting with a getter:** An augmenting getter can augment a getter
    declaration, or the implicit getter of a variable declaration, with all
    prior augmentations applied, by replacing the body of the augmented getter
    with the body of the augmenting getter. Inside the augmenting getter‚Äôs
    body, an `augmented` expression executes the augmented getter‚Äôs body.

*   **Augmenting with a setter:** An augmenting setter can augment a setter
    declaration, or the implicit setter of a variable declaration, with all
    prior augmentations applied, by replacing the augmented setter‚Äôs body with
    the augmenting setter‚Äôs body. Inside the augmenting setter‚Äôs body, an
    `augmented = <expression>` assignment invokes the original setter with the
    value of the expression.

*   **Augmenting a getter and/or setter with a variable:** This is a
    compile-time error in all cases. Augmenting an abstract or external variable
    with a variable is also a compile-time error, as those are actually just
    syntax sugar for getter/setter pairs and do not have an initializer that you
    can augment. *An augmenting variable replaces its augmented variable‚Äôs
    initializer expression, and that can only be done on a declaration that can
    have an initializer expression.*

    We may decide in the future to allow augmenting abstract getters, setters,
    or variables with variables, but for now you can instead use the following
    workaround:

    - Add a new field.
    - Augment the getter and/or setter to delegate to that field.

    If a non-abstract, non-external variable is augmented by an augmenting
    getter or setter, you **can** still augment the variable, as you are only
    augmenting the initializer of the original variable. This is not considered
    to be augmenting the augmenting getter or setter, since those are not
    actually altered.

    The reason for this compile time error is that whether a member declaration
    is a field versus a getter/setter is a visible property of the declaration
    inside the same class or even library:

    *   It determines whether the member can be initialized in a constructor
        initializer list.
    *   It is also a visible distinction when introspecting on a program with
        the analyzer, macros, or mirrors.

    When a declaration is augmented, we don't want the augmentation to be able
    to change any of the known properties of the existing member being
    augmented. For example, we don't allow you to augment a method with a getter
    that returns a function. Augmenting a getter/setter pair with a field would
    change the "can be used in a constructor initializer" property, so we forbid
    it. Augmenting a field with a getter/setter doesn't change that property so
    it is allowed.

*   **Augmenting a variable with a variable:** Augmenting a variable with a
    variable only alters its initializer. External and abstract variables cannot
    be augmented with variables, because they have no initializer expression to
    augment.

    Since the initializer expression is the only meaningful part of the
    augmenting declaration, an initializer expression must be provided. This
    augmenting initializer replaces the original initializer. The augmenting
    initializer may use an augmented` expression which executes the original
    initializer expression when evaluated.

    The `late` property of a variable must always be consistent between the
    augmented variable and its augmenting variables.

    If the original variable declaration does not have a type annotation, then
    the variable's declared type is found using only that declaration,
    without looking at any further augmenting declarations.
    The type can either be inferred from an initializer expression of the
    original variable declaration, be inherited from a superinterface for an
    instance variable, or default to a type of `dynamic` if neither applies.
    *This ensures that augmenting a variable doesn't change its type. That is
    necessary to ensure that macros cannot change the signature of a
    declaration, a signature which may have been depended on by other code,
    or other macros.*

It is a **compile-time error** if:

*   The original and augmenting declarations do not have the same declared
    types (return type for getters, parameter type for setters, declared type
    for variables).

*   An augmenting declaration uses `augmented` when the original declaration has
    no concrete implementation. Note that all external declarations are assumed
    to have an implementation provided by another external source, and
    otherwise they will throw a runtime error when called. An `abstract`
    variable introduces no implementation.

*   An augmenting variable‚Äôs initializer expression uses `augmented` and the
    augmented variable is not a variable with an initializer.

*   A non-writable variable declaration is augmented with a setter. (
    Instead, the author can declare a *non-augmenting* setter that goes
    alongside the implicit getter defined by the final variable.)
    _Non-writable variable declarations are any that does not introduce a
    setter, including non-`late`  `final` variables, `late final` variables
    with an initializer, and `const` variables._

*   A non-final variable is augmented with a final variable. We don't want to
    leave the original setter in a weird state.
    *   A final variable can be augmented with a non-`final` augmenting
        variable, and that will not add any setter. An augmenting variable
        declaration only affects the initializer expression, not setters.

*   A variable is augmented with another variable, and one is `late` and
    the other is not. *(Augmentation cannot change `late`-ness, and since being
    `late` does affect the initializer expression, the augmenting variable is
    required to repeat the `late`.)*

*   A getter or setter base declaration is augmented by an augmenting variable.

*   An abstract or external variable base declarations is augmented by an
    augmenting variable.

*   A late final variable with no initializer expression is augmented by an
    augmenting variable with an initializer expression.
    _A late final variable with no initializer has a setter, while one with an
    initializer does not. An augmentation must not change whether there is a
    setter._

*   A `const` variable is augmented by an augmenting getter. **(TODO: Can a
    const variable be augmented by another const variable, changing its value,
    or is that too weird?)**

### Augmenting enum values

Enum values can _only_ be augmented by enum values, and the implicit getter
introduced by them is not augmentable. The one thing you are allowed to do is to
replace the argument list. There is no way to refer to the original argument
list (although a macro may be able introspect on it and copy over some or all of
the arguments).

An augmenting enum value is allowed to invoke a different constructor than
the original enum value, or provide an argument list where none was present
before.

New enum values may also be defined in the augmentation, and they will be
appended to the current values of the declaration in augmentation application
order. Augmenting an existing enum value never changes the order in which it
appears in `values`.

For example:

```
// main.dart
import augment 'a.dart';
import augment 'c.dart';

enum A {
  first;
}

// a.dart
augment library 'main.dart';

import augment 'b.dart';

augment enum A {
  second;
  augment first; // This is still `first` in values.
}

// b.dart
augment library 'a.dart';

augment enum A {
  augment third;
}

// c.dart
augment library 'main.dart';

augment enum A {
  augment fourth;
}
```

Then `A.values` is `[A.first, A.second, A.third, A.fourth]`.

It is a compile-time error if:

*   An augmenting getter is defined for an enum value. _An enum value counts as
    a constant variable._

### Augmenting constructors

Constructors are (as always) more complex. A constructor marked `augment`
replaces the body of the existing constructor with its body. If the augmenting
constructor has any initializers, they are appended to the original
constructor's initializers, but before any original super initializer or
original redirecting initializer if there is one.

In the augmenting constructor's body, an `augmented()` call invokes the
original constructor's body. The expression has type `void` and evaluates to
`null`. **(TODO: This is slightly under-specified. We can use the current
bindings of the parameters of the augmenting constructor as the initial binding
of parameter variables in the augmented body, or we can execute the body in the
current *scope*, using the same variables as the current body. The latter is
not what we do with functions elsewhere, and allows the `augmented` expression
to modify local variables, but the former introduces different variables than
the ones that existed when evaluating the initializer list. If the initializer
list captures variables in closures, that body may not work.)**

It is a compile-time error if:

*   The function signature of the augmenting constructor does not match the
    signature of the augmented constructor. This means that the parameters must
    be the same (just as for augmenting functions, except here there is no
    return type and no type parameters on the constructor itself). Any
    initializing formals must be the same in both constructors. Any super
    parameters must be the same in both constructors.

    **TODO: Is this the right way to handle initializing formals?**

*   The constructor augmentation parameters specify any default values.
    *Default values are defined solely by the original constructor.*

*   The original constructor is `const` and the augmenting constructor is not,
    or vice versa.

*   The original constructor is a non-redirecting factory constructor and the
    augmenting constructor has an initializer list.

    * The augmenting constructor does not need to repeat the `factory`, but
    augmenting a factory constructor can only create a new factory constructor
    by replacing the augmented constructor‚Äôs body with another. **(TODO: Just
    require the `factory` to be repeated. We happily do that for other
    modifiers)**

*   The original constructor has a super initializer _(super constructor
    invocation at the end of the initializer list)_ and the augmenting
    constructor does too. _An augmentation can replace the implicit default
    `super()` with a concrete super-invocation, but cannot replace a declared
    super constructor._ **(TODO: Why not? We allow ‚Äúreplacing implementation‚Äù,
    and this is *something* like that.)**

**TODO: What about redirecting constructors?**

When augmenting an extension type declaration, the parenthesized clause where
the representation type is specified is treated as a constructor that has a
single positional parameter, a single initializer from the parameter to the
representation field, and an empty body.

This means that an augmentation can add a body to an extension type's
constructor, which isn't otherwise possible. *(But note that there is no
guarantee that any instance of an extension type will have necessarily executed
that body, since you can get instances of extension types through casts or other
conversions that sidestep the constructor.)*

*This is designed in anticipation of supporting [primary constructors][] on
other types in which case the extension type syntax will then be understood by
users to be a primary constructor for the extension type.*

[primary constructors]:
https://github.com/dart-lang/language/blob/main/working/2364%20-%20primary%20constructors/feature-specification.md

### Augmenting external members

When augmenting an `external` member, it is assumed that a real implementation
of that member has already been filled by some tool prior to any augmentations
being applied. Thus, it is allowed to use `augmented` from augmenting members
on external declarations, but it may throw a `NoSuchMethodError` error at
runtime if no implementation was in fact provided.

**NOTE**: Macros should _not_ be able to statically tell if an external body has
been filled in by a compiler, because it could lead to a different result on
different platforms or tools.

**TODO: Should we add a syntax to let the augmentation dynamically detect
whether there is an external implementation to call?**

### Metadata annotations and macro applications

An augmentation declaration may have metadata annotations, including macro
applications. These are appended to the list of metadata annotations on
the original declaration.

## Scoping

The static and instance member namespaces for a type or extension declaration,
augmenting or not, are lexical only. Only the declarations (augmenting or not)
declared inside the actual declaration are part of the lexical scope that
member declarations are resolved in.

_This means that a static or instance member declared in the base declaration
of a class is not *lexically* in scope in an augmentation of that class, just
as an inherited instance member is not in the lexical scope of a class
declaration._

If a member declaration needs to reference a static or instance member declared
in another base or augmenting declaration of the same type, it can use `this.
name` for instance members an `TypeName.name` for static members to be
absolutely sure. Or it can rely on the default if `name` is not in the lexical
scope at all, in which case it‚Äôs interpreted as `this.name` if it occurs inside
a scope where a `this` is available. _This approach is always potentially
dangerous, since any third-party import adding a declaration with the same name
would break the code. In practice that‚Äôs almost never a problem, because
instance members and top-level declarations usually use different naming
strategies._

Example:

```dart
// Main library "some_lib.dart":
import 'other_lib.dart';

part 'some_augment.dart';

const b = 37;

class C {
  const int b = 42;
  bool isEven(int n) {
    if (n == 0) return true;
    return !_isOdd(n - 1);
  }
}

// Augmentation "some_augment.dart":
part of 'some_lib.dart';

import 'also_lib.dart';

augment class C {
  bool _isOdd(int n) => !this.isEven(n - 1);
  void printB() { print(b); }  // Prints 37
}
```

This code is fine. Code in `C.isEven` can refer to members added
in the augmentation like `_isOdd()` because there is no other `_isOdd` in
scope, and code in `C._isOdd` works too by explicitly using `this.isEvent` to
ensure it calls the correct method.

You can visualize the namespace nesting sort of like this:

```
some_lib.dart       :
                    :<part of----------
.---------------------------------------.
| import scope:                         |
| other_lib imports                     |
'---------------------------------------'
         ^          :         ^
         |          :         |
         |          : .-----------------.
         |          : | import scope:   |
         |          : | also_lib imports|
         |          : '-----------------'
         |          :         |
.--------------------------------------.
| top-level declaration scope:         |
| const b = 37                         |
| class C (fully augmented class)      |
|                                      |
'--------------------------------------'
         ^          :         ^
         |          :         |
.-----------------. : .----------------.
| class C         | : | augment class C|
| const b = 42    | : | _isOdd()       |
| isEven()        | : |                |
'-----------------' : '----------------'
         ^          |         ^
         |          |         |
.-----------------. | .-----------------.
| C.isEven() body | | | C._isOdd() body |
'-----------------' | '-----------------'
```

Each part files has its own combined import scope, extending that of its
parent, and its own member declarations scopes for each declared member,
introducing a lexical scope for the declaration‚Äôs contents. In the middle, each
passes through the shared library declaration namespaces for the top-level
instances themselves.

## Syntax

The grammar changes are fairly simple. The grammar is modified to allow an
`augment` modifier before various declarations:

```
topLevelDeclaration ::= classDeclaration
  | mixinDeclaration
  | extensionTypeDeclaration
  | extensionDeclaration
  | enumType
  | typeAlias
  | 'external' functionSignature ';'
  | 'external' getterSignature ';'
  | 'external' setterSignature ';'
  | 'external' finalVarOrType identifierList ';'
  | 'augment'? functionSignature functionBody
  | 'augment'? getterSignature functionBody
  | 'augment'? setterSignature functionBody
  | 'augment'? ('final' | 'const') type? staticFinalDeclarationList ';'
  | 'augment'? 'late' 'final' type? initializedIdentifierList ';'
  | 'augment'? 'late'? varOrType initializedIdentifierList ';'

classDeclaration ::= 'augment'? (classModifiers | mixinClassModifiers)
    'class' typeWithParameters superclass? interfaces?
    '{' (metadata classMemberDeclaration)* '}'
  | 'augment'? classModifiers 'mixin'? 'class' mixinApplicationClass

mixinDeclaration ::= 'augment'? 'base'? 'mixin' typeIdentifier
  typeParameters? ('on' typeNotVoidNotFunctionList)? interfaces?
  '{' (metadata mixinMemberDeclaration)* '}'

extensionDeclaration ::=
    'extension' typeIdentifierNotType? typeParameters? 'on' type
    extensionBody
  | 'augment' 'extension' typeIdentifierNotType typeParameters?
    extensionBody

extensionBody ::= '{' (metadata classMemberDeclaration)* '}'

extensionTypeDeclaration ::=
  'augment'? 'extension' 'type' 'const'? typeIdentifier
  typeParameters? representationDeclaration interfaces?
  '{' (metadata classMemberDeclaration)* '}'

enumType ::= 'augment'? 'enum' typeIdentifier
  typeParameters? mixins? interfaces?
  '{' enumEntry (',' enumEntry)* (',')?
  (';' (metadata classMemberDeclaration)*)? '}'

typeAlias ::= 'augment'? 'typedef' typeIdentifier typeParameters? '=' type ';'
  | 'augment'? 'typedef' functionTypeAlias

classMemberDeclaration ::= declaration ';'
  | 'augment'? methodSignature functionBody

enumEntry ::= metadata 'augment'? identifier argumentPart?
  | metadata 'augment'? identifier typeArguments?
    '.' identifierOrNew arguments

declaration ::= 'external' factoryConstructorSignature
  | 'external' constantConstructorSignature
  | 'external' constructorSignature
  | ('external' 'static'?)? getterSignature
  | ('external' 'static'?)? setterSignature
  | ('external' 'static'?)? functionSignature
  | 'external' ('static'? finalVarOrType | 'covariant' varOrType) identifierList
  | 'external'? operatorSignature
  | 'abstract' (finalVarOrType | 'covariant' varOrType) identifierList
  | 'augment'? 'static' 'const' type? staticFinalDeclarationList
  | 'augment'? 'static' 'final' type? staticFinalDeclarationList
  | 'augment'? 'static' 'late' 'final' type? initializedIdentifierList
  | 'augment'? 'static' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'covariant' 'late' 'final' type? identifierList
  | 'augment'? 'covariant' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'late'? 'final' type? initializedIdentifierList
  | 'augment'? 'late'? varOrType initializedIdentifierList
  | 'augment'? redirectingFactoryConstructorSignature
  | 'augment'? constantConstructorSignature (redirection | initializers)?
  | 'augment'? constructorSignature (redirection | initializers)?
```

**TODO: Define the grammar for the various `augmented` expressions.**

It is a compile-time error if:

*   A function, getter, setter, or operator declaration marked `augment` is also
    abstract. **(TODO: Remove. This can be used to add metadata.)**

*   A declaration marked `augment` is also marked `external`. **(TODO: Probably
    remove for functions, so change to ‚ÄúA variable declaration‚Äù. A macro should
    be able to implement a method as an external with a `@JS()` annotation.)**

## Static semantics

The application of augmentation declarations to a base declaration produces
something that looks and behaves like a single declaration: It has a single
name, a single type or function signature, and it‚Äôs what all references
to the *name* refers to inside and outside of the library.

Unlike before, that single *semantic declaration* now consists of multiple
*syntactic* declarations (one base declaration, the rest augmenting
declarations, with a given augmentation application order), and the properties
of the combined semantic declaration can be derived from the syntactic
declarations.

We redefine a number of semantic functions to now work on a *stack* of
declarations (the declarations for a name in bottom to top order), so that
existing semantic definitions keep working.

### Example: Class declarations

#### Super-declarations

The specification of class modifiers introduced a number of predicates on
*declarations*, to check whether the type hierarchy is well formed and the
class modifiers are as required, before the static semantics have even
introduced *types* yet. We modify those predicates to apply to a stack of
augmenting and base declarations as follows:

*   A a non-empty *stack* of syntactic class declarations, *C*, has a
    declaration *D* as *declared super-class* if:
    *   *C* starts with an (augmenting or not) class declaration *C0* and either
        *   *C0* has an `extends` clause whose type clause denotes the
            declaration *D*, or
        *   *C0* is an augmenting declaration, so *C* continues with a
            non-empty *C<sub>rest</sub>*, and *C<sub>rest</sub>* has *D* as
            declared super-class.
*   A a non-empty *stack* of syntactic class declarations, *C*, has a
    declaration *D* as *declared super-interface* if:
    *   *C* starts with an (augmenting or not) class declaration *C0* and either
        *   *C0* has an `implements` clause with an entry whose type clause
            denotes the declaration *D*, or
        *   *C0* is an augmenting declaration, so *C* continues with a
            non-empty *C<sub>rest</sub>*, and *C<sub>rest</sub>* has *D* as
            declared super-interface.
*   A a non-empty *stack* of syntactic class declarations, *C*, has a
    declaration *D* as *declared super-mixin* if:
    *   *C* starts with an (augmenting or not) class declaration *C0* and either
        *   *C0* has a `with` clause with an entry whose type clause denotes
            the  declaration *D*, or
        *   *C0* is an augmenting declaration, so *C* continues with a
            non-empty *C<sub>rest</sub>*, and *C<sub>rest</sub>* has *D* as
            declared super-mixin.

#### Members

A class declaration stack, *C*, of a one non-augmenting and zero or more
augmenting class declarations, defines an *augmented interface* (member
signatures) and *augmented implementation* (instance members declarations)
based on the individual syntactic declarations.

A non-empty class declaration stack, *C*, has the following set of instance
member declarations:

*   Let *C<sub>top</sub>* be the latest declaration of the stack, and
    *C<sub>rest</sub>* the rest of the stack.
*   If *C<sub>top</sub>* is a non-augmenting declaration, the declarations of
    *C* is the set of syntactic instance member declarations of
    *C<sub>top</sub>*.
*   Otherwise let *P* be the set of member declarations of the non-empty stack
    *C<sub>rest</sub>*.
*   and the member declarations of *C* is the set *R* defined as containing
    only the following elements:
    *   A singleton stack of each syntactic instance member declaration *M* of
        *C<sub>top</sub>*, where *M* is a non-augmenting declaration.
    *   The elements *N* of *P* where *C<sub>top</sub>* does not contain an
        augmenting instance member declaration with the same name _(mutable
        variable declarations have both a setter and a getter name)_.
    *   The stacks of a declaration *M* on top of the stack *N*, where *N* is a
        member of *P*, *M* is an augmenting instance member declaration of
        *C<sub>top</sub>*, and *M* has the same name as *N*.

And we can whether such an instance member declaration stack, *C*, *defines an
abstract method* as:

*   Let *C<sub>top</sub>* be the latest element of the stack and
    *C<sub>rest</sub>* the rest of the stack.
*   If *C<sub>top</sub>* is a non-variable declaration, and is not declared
    `abstract`, the *C* doe
*   If *C<sub>top</sub>* declares a function body, then *C* does not define an
    abstract method.
*   Otherwise *C* defines an abstract method if *C<sub>rest</sub>* defines an
    abstract method.

(This is just for methods, we will define it more generally for members,
including variable declarations.)

### Example: Instance methods

#### Properties

Similarly we can define the properties of stacks of member declarations.

For example, we define the *augmented parameter list* of a non-empty stack,
*C*, of augmentations on a base function declaration as:

*   Let *C<sub>top</sub>* be the latest element of the stack and
    *C<sub>rest</sub>* the rest of the stack.
*   If *C<sub>top</sub>* is not an augmenting declaration, its augmented
    parameter list is its actual parameter list. _(And *C<sub>rest</sub>* is
    known to be empty.)_
*   Otherwise *C<sub>top</sub>* is an augmenting declaration with a parameter
    list which must have the same parameters (names, positions, optionality and
    types) as its augmented declaration, except that it is not allowed to
    declare default values for optional parameters.
    *   Let *P* be the augmented parameter list of *C<sub>rest</sub>*.
    *   The augmented parameter list of *C<sub>top</sub>* is then the parameter
        list of *C<sub>top</sub>*, updated by adding to each optional parameter
        the default value of the corresponding parameter in *P*, if any.

_This will usually be exactly the parameter list of the original non-augmenting
declaration, but the ordering of named parameters may differ. This is mostly
intended as an example, in practice the augmented parameter list can just be
the parameter list of the original non-augmenting declaration, but it‚Äôs more
direct and clearly correct to use the actual parameter list of the declaration
when creating the parameter scope that its body will run in._

Similarly we define the _augmented function type_ of the declaration stack.
Because of the restrictions we place on augmentations, they will all have the
same function type as the original non-augmenting declaration, but again it‚Äôs
simpler to assign a function type to every declaration.

#### Invocation

When invoking an instance member on an object, the current specification looks
up the corresponding implementation on the class of the runtime-type of the
receiver, traversing super-classes, until it it finds a non-abstract
declaration or needs to search past `Object`. The specification then defines
how to invoke that method declaration, with suitable contexts and bindings.

We still define the same thing, only the result of lookup is not a single
declaration, but a stack of augmenting declarations on top of a base
declaration, and while searching, we skip past *declaration stacks* that define
an abstract method. The resulting stack is the *member definition*, or
*semantic declaration*, which is derived from the syntactic declarations in the
source.

Invoking a *stack*, *C*, of instance method declarations on a receiver object
*o* with an argument list *A* and type arguments *T*, is then defined as
follows:

*   Let *C<sub>top</sub>* be the latest declaration on the stack (the last
    applied augmentation in augmentation application order), and
    *C*<sub>*rest*</sub> the rest of the stack.
*   If *C<sub>top</sub>* has a function body *B* then:
    *   Bind actuals to formals (using the usual definition of that), binding
        the argument list *A* and type arguments *T* to the *augmented
        parameter list* of *C*<sub>*top*</sub> and type parameters of
        *C<sub>top</sub>*. This creates a runtime parameter scope which has the
        runtime class scope as parent scope (the lexical scope of the class,
        except that type parameters of the class are bound to the runtime type
        arguments of those parameters for the instance *o*).
    *   Execute the body *B* in this parameter scope, with `this` bound to *o*.
    *   If *B* contains an expression of the form `augmented<TypeArgs>(args)`
        (type arguments omitted if empty), then:
        *   The static type of `augmented` is the augmented function type of
            *C<sub>rest</sub>*. The expression is type-inferred as a function
            value invocation of a function with that static type.
        *   To evaluate the expression, evaluate `args` to an argument list
            *A2*, invoke *C<sub>rest</sub>* with argument list *A2* and type
            arguments that are the types of `TypeArgs`. The result of
            `augmented<TypeArgs>(args)` is the same as the result of that
            invocation (returned value or thrown error).
    *   _There would have been a compile-time error if there is no earlier
        declaration with a body._
    *   The result of invoking *C* is the returned or thrown result of
        executing *B*.
*   Otherwise, the result of the invocation of *C* is the result of invoke
    *C<sub>rest</sub>* on *o* with argument list *A* and type arguments *T*.
    *   _This will eventually find a body to execute, otherwise *C* would have
        defined an abstract method, and would not have been invoked to begin
        with._

## Documentation comments

Documentation comments are allowed in all the standard places in library
augmentations. It is up to the tooling to decide how to present such
documentation comments to the user, but they should generally be considered to
be additive, and should not completely override the original comment. In other
words, it is not the expectation that augmentations should duplicate the
original documentation comments, but instead provide comments that are specific
to the augmentation.

## Changelog

### 1.22

*   Unify augmentation libraries and parts.
    [Parts with imports specification][parts_with_imports.md] moved into
    separate document, as a stand-alone feature that is not linked to
    augmentations.
*   Augmentation declarations can occur in any file, whether a library or part
    file. Must occur ‚Äùbelow‚Äù the base declaration (later in same file or
    sub-part) and ‚Äúafter‚Äù any prior applied augmentation that it modifies
    (below, or in a later sub-part of a shared ancestor).
*   Suggest a stronger ordering *lint*, where the augmentation must be ‚Äúbelow‚Äù
    the augmentation it is applied after. That imples that all declarations with
    the same name are on the same path in the library file tree, so that
    reordering `part` directives does not change augmentation application order.
*   Change the lexical scope of augmenting class-like declarations to only
    contain the member declarations that are syntactically inside the same
    declaration, rather than collecting all member declarations from all
    augmenting or non-augmenting declarations with the same name, and making
    them all available in each declaration.
*   Avoid defining a syntactic merging, since it requires very careful scope
    management, which isn‚Äôt necessary if we can just extend properties that are
    currently defined for single declarations to the combination of a
    declaration plus zero or more augmentations.

### 1.21

*   Add a compile-time errors for wrong usages of `augmented`.

### 1.20

*   Change the `extensionDeclaration` grammar rule such that an augmenting
    extension declaration cannot have an `on` clause. Adjust other rules
    accordingly.

### 1.19

*   Change the phrase 'augmentation library' to 'library augmentation',
    to be consistent with the rename which was done in 1.15.

### 1.18

*   Add a grammar rule for `enumEntry`, thus allowing them to have the
    keyword `augment`.

### 1.17

*   Introduce compile-time errors about wrong structures in the graph of
    libraries and augmentation libraries formed by directives like `import`
    and `import augment` (#3646).

### 1.16

*   Update grammar rules and add support for augmented type declarations of
    all kinds (class, mixin, extension, extension type, enum, typedef).

*   Specify augmenting extension types. Clarify that primary constructors
    (which currently only exist for extension types) can be augmented like
    other constructors (#3177).

### 1.15

*   Change `library augment` to `augment library`.

### 1.14

*   Change `augment super` to `augmented`.

### 1.13

*   Clarify which clauses are (not) allowed in augmentations of certain
    declarations.
*   Allow adding an `extends` clause in augmentations.

### 1.12

*   Update the behavior for variable augmentations.

### 1.11

*   Alter and clarify the semantics around augmenting external declarations.
*   Allow non-abstract classes to have implicitly abstract members which are
    implemented in an augmentation.

### 1.10

*   Make `augment` a built-in identifier.

### 1.9

*   Specify that documentation comments are allowed, and should be considered to
    be additive and not a complete override of the original comment. The rest of
    the behavior is left up to implementations and not specified.

### 1.8

*   Specify that augmented libraries and their augmentations must have the same
    language version.

*   Specifically call out that augmentations can add and augment enum values,
    and specify how that works.

### 1.7

*   Specify that augmentations must contain all the same keywords as the
    original declaration (and no more).

### 1.6

*   Allow class augmentations to use different names for type parameters. This
    isn't particular valuable, but is consistent with functions augmentations
    which are allowed to change the names of positional parameters.

*   Specify that a non-augmenting declaration must occur before any
    augmentations of it, in merge order.

*   Specify that augmentations can't have parts (#2057).

### 1.5

*   Augmentation libraries share the same top-level declaration and private
    scope with the augmented library and its other augmentations.

*   Now that enums have members, allow them to be augmented.

*   Compile-time error if a non-`late` augmenting instance variable calls the
    initializer for a `late` one.

### 1.4

*   When inferring the type of a variable, only the original variable's
    initializer is used.

### 1.3

*   Constructor and function augmentations can't define default values.

### 1.2

*   Specify that augmenting constructor initializers are inserted before the
    original constructor's super or redirecting initializer if present (#2062).
*   Specify that an augmenting type must replicate the original type's type
    parameters (#2058).
*   Allow augmenting declarations to add metadata annotations and macro
    applications (#2061).

### 1.1

*   Make it an error to apply the same augmentation multiple times (#1957).
*   Clarify type parameters and parameter modifiers in function signature
    matching (#2059).

### 1.0

Initial version.

# Augmentation Libraries

Author: rnystrom@google.com, Version: 1.0

Augmentation libraries allow splitting a Dart library into files. Unlike part
files, each augmentation has its [own imports][part imports] and top-level
scope. Augmentations can add new top-level declarations, inject new members into
classes, and wrap functions and variables in additional code.

[part imports]: https://github.com/dart-lang/language/issues/519

## Motivation

Dart libraries are the unit of code reuse. When an API is too large to fit into
a single file, you can usually split it into multiple libraries and then have
one main library export the others. That works well when the functionality in
each file is made of separate top-level declarations.

However, sometimes a single *class* declaration is too large to fit comfortably
in a file. Dart libraries and even part files are no help there. Because of
this, users have asked for something like partial classes in C# ([#252][] 45 üëç,
[#678][] 15 üëç). C# also supports splitting [the declaration and implementation
of methods into separate files][partial].

[#252]: https://github.com/dart-lang/language/issues/252
[#678]: https://github.com/dart-lang/language/issues/678
[partial]: https://github.com/jaredpar/csharplang/blob/partial/proposals/extending-partial-methods.md

### Generated code

Size isn't the only reason to split a library into multiple files. Code
generation is common in Dart. [AngularDart][] compiles HTML templates to Dart files.
The [freezed][] and [built_value][] packages generate Dart code to implement
immutable data structures.

[angulardart]: https://github.com/angulardart
[freezed]: https://pub.dev/packages/freezed
[built_value]: https://pub.dev/packages/built_value

In cases like this, it's important to have the hand-authored and
machine-generated code in separate files so that the code generator doesn't
inadvertently erase a user's code. AngularDart generates a separate library for
the component. The freezed and built_value packages generate part files.

### Macros

The language team is investigating adding [macros][] to Dart. In theory, this
would *reduce* the need for text-based code generation language features.
Instead of code generation, users could write macros instead. They'd let the
compiler expand them, and not worry about anything ending up on disk.

[macros]: https://github.com/dart-lang/language/blob/master/working/macros/feature-specification.md

If users never needed to fix bugs in macros, look at stack traces, step into
code in a debugger, or navigate to the location of a compile error, that would
be true. But understanding and digging into code is fundamental to programming.
An error could be thrown from code generated by a macro. A macro might generate
code that produces a compile error (either deliberately because the macro was
misused or because the macro itself has a bug). A user might be profiling their
application and a macro might generate particularly slow code.

In all of those cases, users need some way to read and understand code produced
by macros. So, even if that code is generated automatically by the compiler as
part of macro expansion, it's still useful to have it be in a canonical
well-specified form that users can understand.

This proposal defines that format. The idea is that a Dart compiler executes
macros and then produces one or more augmentation library files that contain all
of the changes that the macros made to the library where they are applied. The
language then automatically merges those augmentations into the main library.

But augmentations aren't *only* a serialization format for macros. They are a
first-class language feature that can be produced by non-macro code generators
or written by hand by users who simply want to break a giant library or class
into smaller files.

## Augmentation libraries

An augmentation library is a separate file that "augments" another "main"
library. An augmentation is very similar to a normal Dart library: It has its
own top-level scope that may contain all kinds of declarations&mdash;functions,
classes, variables, etc. The main differences are:

*   Declarations in the augmentation library implicitly become declarations in
    the main library it augments.

*   An augmentation may add new members to existing types in the main library.

*   A function in the augmentation may wrap the body of a function in the main
    library.

*   A variable in the augmentation may wrap the initializer of a variable in the
    main library.

The latter three can't be expressed today using only imports, exports, and part
files.

### Defining an augmentation

An augmentation has almost the same syntax and semantics as a normal Dart
library. Augmentations are distinguished by a special `library` directive with
an `augment` modifier, like so:

```dart
library augment 'main_library.dart';
```

**TODO: Better syntax? How does this interact with [import short-hand
syntax][import]?**

[import]: https://github.com/dart-lang/language/blob/master/working/0649%20-%20Import%20shorthand/proposal.md

The URL points to the main library that this augmentation is applied to.

After that, an augmentation library may contain anything a regular Dart library
can contain: classes, functions, constants, etc. Public declarations in the
augmentation library are implicitly merged into the main library. It is as if
the main library both imports and exports the augmentation library.

It is a compile-time error if:

*   A public top-level declaration in an augmentation has the same name as a
    declaration in the main library (unless it is an *augmenting* declaration,
    described below).

*   A private declaration in an augmentation is marked `augment`.

    **TODO: Revise this if we add support for [private imports][].**

### Applying an augmentation library

A main library applies an augmentation to itself using a new import directive
that looks like this:

```dart
import augment 'some_augmentation.dart';
```

**TODO: Better syntax? How does this interact with [import short-hand
syntax][import]?**

This directive tells the compiler to read the given library augmentation and
merge its declarations into this library. It is a compile-time error if:

*   The library referenced in an `import augment` directive is not an
    augmentation and does not have a `library augment` directive.

*   The library referenced in a `library augment` directive does not have an
    `import augment` directive pointing back to this augmentation.

Since the main library and its augmentation both point to each other, these
rules imply that a given augmentation file can only be used to augment a single
library.

A library may apply multiple augmentations to itself. Also, augmentation files
may themselves contain `import augment` directives. The entire tree of
augmentations is recursively applied to the main library. In most cases, the
order that augmentations are applied doesn't matter, but it is visible in a
couple of corners where the merge process involves "appending". For those cases,
merge order is defined as a depth-first pre-order traversal of the `import
augment` directives in the main library and its augmentations. So, in:

```
// main.dart
import augment 'a.dart';
import augment 'c.dart';

// a.dart
library augment 'main.dart';

import augment 'b.dart';

// b.dart
library augment 'a.dart';

// c.dart
library augment 'main.dart';
```

The merge order is `a.dart`, `b.dart`, then `c.dart`.

**TODO: Should it be a compile-time error if the main library and augmentation
are in different packages?**

**TODO: Can the main library and augmentations have different language
versions?**

## Augmenting declarations

Unlike part files, which can only add entirely new declarations, an augmentation
can also modify existing declarations in the main library. This can mean adding
new members to an existing type, or even modifying the code of an existing
declaration. There are a few supported operations which are all marked
syntactically using an `augment` modifier.

Often, an augmentation wants to also preserve and run the code of the original
declaration it augments (hence the name "augmentation"). It may want run before
the original code, after it, or both. To allow that, we allow a new expression
syntax inside the bodies of augmenting members. Inside a member marked
`augment`, an expression like `augment super` can be used to refer to the
original function, getter, setter, or variable initializer.

**TODO: I'm not sold on `augment super`. Is there a better syntax?**

The same declaration can be augmented multiple times by separate augmentation
libraries. When that happens, the merge order defined previously determines
which order the wrapping is applied.

### Augmenting types

A class, mixin, or extension declaration can be marked with an `augment`
modifier:

**TODO: If enums are [extended to allow members][enhanced enums], allow enums
here too.**

[enhanced enums]: https://github.com/dart-lang/language/blob/master/working/0158%20-%20Enhanced%20Enum/feature_specification.md

```dart
augment class SomeClass {
  // ...
}
```

This means that instead of creating a new type declaration, the augmentation
modifies a corresponding one in the main library.

A class augmentation may specify `implements` and `with` clauses. When those
appear, the specified superinterfaces and mixins are appended to the main
class's superinterface and mixin lists, respectively.

**TODO: Is appending the right order for mixins?**

Any instance or static members defined in the body of the type are added to the
instance or static namespace of the corresponding type in the main libray. In
other words, the augmentation can add new members to an existing type.

**TODO: Can an augmentation on enums add new enum cases?**

Instance and static members inside a type may themselves be augmentations. In
that case, they augment the corresponding members in the original type
declaration according to the rules in the following subsections.

It is a compile-time error if:

*   The augmenting type and corresponding type are not the same kind: class,
    mixin, extension. You can't augment a class with a mixin, etc.

*   The augmenting type declares any type parameters or an `extends` clause.
    Only the main declaration can specify those.

    **TODO: We could consider allowing an `extends` clause if the main
    declaration doesn't have one.**

*   The augmenting type is marked `abstract`. The main library determines
    whether the class is abstract or not.

### Augmenting functions

A top-level function, static method, instance method, or operator may be
augmented to wrap the original code in additional code:

```dart
// Wrap the original function in profiling:
augment int slowCalculation(int a, int b) {
  var watch = Stopwatch()..start();
  var result = augment super(a, b);
  print(watch.elapsedMilliseconds);
  return result;
}
```

The augmentation replaces the original function body with the augmenting code.
Inside the augmentation body, a special `augment super()` expression may be used
to execute the original function body. That expression takes an argument list
matching the original function's parameter list and returns the function's type.

**TODO: Better syntax than `augment super`?**

The augmenting function does not have to pass the same arguments to `augment
super()` as were passed to it. It may call it once, more than once, or not at
all.

It is a compile-time error if:

*   The signature of the function augmentation does not exactly match the
    original function. This means the return types must be the same; there must
    be the same number of positional, optional, and named parameters; the types
    of corresponding positional and optional parameters must be the same; and
    the names and types of named parameters must be the same.

*   The original function is declared `external` and the augmenting function
    uses `augment super()`.

    **TODO: Instead of making this an error, should we add a syntax that lets
    the augmentation dynamically detect whether there is an original body to
    wrap?**

**TODO: Should we allow augmenting functions to add parameters? If so, how does
this interact with type checking calls to the function?**

### Augmenting variables, getter, and setters

Augmentations on variables, getters, and setters are more complex because the
language treats those as [mostly interchangeable][uniform]. We want to preserve
that flexibility in augmentations. For example, an augmentation might want to
wrap access to a variable in an augmenting getter. Or an augmentation may want
to fill in the body of an unimplemented getter by using a backing variable
declaration.

[uniform]: https://en.wikipedia.org/wiki/Uniform_access_principle

You can think of variable, getter, and setter declarations all as ways to define
a higher-level "property" construct. A property has a name and a type. It may
have one or more other capabilities:

*   **A backing storage location.** You get this when you declare a variable.
    This also enables an instance variable to be assigned in a constructor
    initializer list. A variable may also have an **initializer** expression
    that gets run either lazily for top-level variables and static fields or at
    construction time when an instance is created.

*   **A getter function.** This function body is provided explicitly when you
    declare a getter. A variable declaration provides an implicit getter body
    that returns the value in the backing storage location. (Late variables do
    some additional checking in that implicit body.)

*   **A setter function.** Again, a setter declaration provides this body
    explicitly. A non-final variable declaration provides an implicit setter
    body that stores the given value in the storage location. (Again, late
    variables do some additional checks.)

Declarations may be marked `abstract` or `external` and, if so, those are
mapped over to the corresponding getter and setter functions.

Augmentations on variables, getters, and setters works mostly at the level of
these separate capabilities. For example, augmenting a variable with a getter
replaces the variable's implicit getter body with the augmenting getter's.

More specifically:

*   **Augmenting with a getter:** A getter in an augmentation library can
    augment a getter in the main library or the implicit getter defined by a
    variable in the main library. Inside the augmenting body, an `augment super`
    expression invokes the original getter.

*   **Augmenting with a setter:** A setter in an augmentation library can
    augment a setter in the main library or the implicit setter defined by a
    non-final variable in the main library. Inside the augmenting setter, an
    `augment super =` expression invokes the original setter.

*   **Augmenting a getter and/or setter with a variable:** A variable in an
    augmentation library can augment a getter in the main library. A non-final
    variable can augment a setter as well. The implicit getter and setter
    defined by the augmenting variable replace the getter and setter in the main
    library.

*   **Augmenting a variable with a variable:** The original storage location is
    discarded and the original implicit getter and setter are replaced with the
    new implicit ones. *In most cases, the distinction of which implicit
    getter/setter is kept is not visible. But if augmenting a `late` variable
    with a non-`late` one or vice versa, the bodies behave differently in
    user-visible ways.*

    The original initializer expression is replaced with the augmenting
    variable's initializer if it has one. The augmenting initializer may use an
    `augment super` expression which executes the original initializer
    expression when evaluated.

    **TODO: What if the augmenting variable doesn't have an initializer?**

It is a compile-time error if:

*   The original and augmenting declarations do not have the same type.

*   An augmenting declaration uses `augment super` when the original declaration
    is marked `external`.

*   An augmenting initializer uses `augment super` and the original declaration
    is not a variable with an initializer.

*   A final variable is augmented with a setter. (Instead, the augmentation
    library can declare a *non-augmenting* setter that goes alongside the
    implicit getter defined by the final variable.)

*   A non-final variable is augmented with a final variable. We don't want to
    leave the original setter in a weird state.

### Augmenting constructors

Constructors are (as always) more complex. A constructor marked `augment`
replaces the body of the corresponding constructor in the main library with its
body. It appends its initializer list to the original constructor's. In the
augmenting constructor's body, an `augment super()` call invokes the original
constructor's body.

It is a compile-time error if:

*   The signature of the constructor augmentation does not exactly match the
    original constructor. This means there must be the same number of
    positional, optional, and named parameters; the types of corresponding
    positional and optional parameters must be the same; and the names and types
    of named parameters must be the same. Any initializing formals must be the
    same in both constructors.

    **TODO: Is this the right way to handle initializing formals?**

*   The original constructor is `const` and the augmenting constructor is not
    or vice versa.

*   The original constructor is a factory constructor and the augmenting
    constructor has an initializer list.

**TODO: What about redirecting constructors?**

## Scoping

Unlike part files, an augmentation library has its own top-level lexical scope
distinct from the main library. It may contain imports separate from the main
library. Any exports it contains are applied to the main library and become
exports from the main library's namespace. Private identifiers in the
augmentation library are distinct from private names in the main library.

**TODO: We'll probably want something like [private imports][] to enable an
augmentation to access private members in the main library.**

[private imports]: https://github.com/dart-lang/language/blob/master/working/packaged-libraries/feature-specification.md#private-imports

However, *the static and instance member namespaces for an augmented type are
shared across the declaration of the type in the main library and all
augmentations of that type.* Identifiers in the bodies of members (both implicit
ones and explicit uses like `this.` or `TypeName.`) are resolved against that
complete merged namespace. For example:

```dart
// Main library "some_lib.dart":
import augment 'some_augment.dart';

const a = 1;

class C {
  bool isEven(int n) {
    if (n == 0) return true;
    return !isOdd(n - 1);
  }
}

// Augmentation "some_augment.dart":
library augment 'some_lib.dart';

const b = 2;

augment class C {
  bool isOdd(int n) => !isEven(n - 1);
}
```

This code is fine. Code in C in the main library can refer to members added in
the augmentation library like `isOdd()`. Meanwhile, code in the augmentation
can see members like `isEven()` declared in the main library.

You can visualize the namespace nesting sort of like this:

```
some_lib.dart        some_augment.dart

.-----------------.  .----------------.
| top-level       |  | top-level      |
| const a         |  | const b        |
'-----------------'  '----------------'
         ^                   ^
         |                   |
.-------------------------------------.
| class C instance members            |
| isEven()                            |
| isOdd()                             |
'-------------------------------------'
         ^                   ^
         |                   |
.-----------------.  .----------------.
| C.isEven() body |  | C.isOdd() body |
'-----------------'  '----------------'
```

Each library has its own namespace chain from its own member bodies out to its
own top-level lexical namespace. But in the middle, each passes through the
shared class namespaces for the instance and static members.

This implies that the bodies of members cannot be resolved until after
augmentations have been merged. We don't know what namespace `isEven()` or
`isOdd()` will be found in until the namespace for the class has had *all*
augmentations merged in.

Fortunately, augmentations can be applied purely syntactically. In order to
merge augmentations into the main library, we only need to match declarations
by name. So a Dart compiler can theoretically:

1.  Parse the main library and all of its augmentations.
2.  Merge the augmentations to determine the complete set of declarations in
    all types.
3.  Resolve and type-check the main library and all of its augmentations now
    that all type namespaces are complete.

## Syntax

The grammar changes are fairly simple. A main library can apply an augmentation
using a new directive:

```
importOrExport ::= libraryImport
  | libraryAugmentImport
  | libraryExport

libraryAugmentImport ::= metadata 'import' 'augment' uri ';'
```

A library directive may contain `augment` followed by a URI to denote the file
as an augmentation library:

```
libraryName ::= metadata 'library'
    ( dottedIdentifierList | 'augment' uri ) ';'
```

In an augmentation library, the grammar is slightly modified to allow an
`augment` modifier before various declarations:

```
topLevelDeclaration ::= classDeclaration
  | mixinDeclaration
  | extensionDeclaration
  | enumType
  | typeAlias
  | 'external' functionSignature ';'
  | 'external' getterSignature ';'
  | 'external' setterSignature ';'
  | 'augment'? functionSignature functionBody
  | 'augment'? getterSignature functionBody
  | 'augment'? setterSignature functionBody
  | 'augment'? ('final' | 'const') type? staticFinalDeclarationList ';'
  | 'augment'? 'late' 'final' type? initializedIdentifierList ';'
  | 'augment'? 'late'? varOrType initializedIdentifierList ';'

classDeclaration ::=
  'augment'? 'abstract'? 'class' identifier typeParameters?
  // Rest of rule...

mixinDeclaration ::= 'augment'? 'mixin' identifier typeParameters?
  // Rest of rule...

classMemberDeclaration ::= declaration ';'
  | 'augment'? methodSignature functionBody

declaration ::= 'external' factoryConstructorSignature
  | 'external' constantConstructorSignature
  | 'external' constructorSignature
  | ('external' 'static'?)? getterSignature
  | ('external' 'static'?)? setterSignature
  | ('external' 'static'?)? functionSignature
  | 'external'? operatorSignature
  | 'augment'? 'static' 'const' type? staticFinalDeclarationList
  | 'augment'? 'static' 'final' type? staticFinalDeclarationList
  | 'augment'? 'static' 'late' 'final' type? initializedIdentifierList
  | 'augment'? 'static' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'covariant' 'late'? varOrType initializedIdentifierList
  | 'augment'? 'late'? 'final' type? initializedIdentifierList
  | 'augment'? 'late'? varOrType initializedIdentifierList
  | redirectingFactoryConstructorSignature
  | constantConstructorSignature (redirection | initializers)?
  | constructorSignature (redirection | initializers)?
```

**TODO: Define the grammar for the various `augment super` expressions.**

It is a compile-time error if:

*   A function, getter, setter, or operator declaration marked `augment` is also
    abstract.

*   A declaration marked `augment` is also marked `external`.

## Static semantics

Previous sections informally describe the process of applying augmentations to
the main library, but here's a more complete mechanical description of the
process a theoretical Dart implementation could take.

To apply an augmentation to the main library:

1.  For each `import augment` directive in the augmentation library, in
    syntactic order:

    1.  Apply the imported augmentation to the main library using this
        procedure, recursively.

1.  For each public declaration in the augmentation:

    **TODO: If we allow private imports, update this allow to merging private
    declarations whose name matches a declaration in the main library.**

    1.  Merge the declaration into the main library's top-level namespace using
        the following procedure.

To merge a declaration into a namespace:

1.  If the declaration is marked `augment`:

    1.  If the namespace does not have a declaration with that name, error.

    1.  If the corresponding declaration in the namespace is not the same kind,
        error. "Kind" means class, mixin, function, etc. Getters, setters, and
        variables are all considered to have the same kind. In other words, you
        can't try to augment a class with a function or anything weird like
        that.

    1.  If the declaration is a class or mixin:

        1.  Append the types in the augmentation's `implements` clause to the
            main type's clause.

        1.  Append the types in the augmentation's `on` clause to the main
            type's clause.

        1.  Append the types in the augmentation's `with` clause to the main
            type's clause.

        1.  Merge each instance member in the augmenting type into the instance
            namespace of the main type.

        1.  Merge each static member in the augmenting type into the static
            namespace of the main type.

    1.  Else, if the declaration is a function, getter, setter, or operator:

        1.  Replace the body of the main function with the augmenting function's
            body. Inside the augmenting body, a `super augment()`, `super
            augment`, `super augment =`, or `super augment <op>` expression as
            appropriate calls the original function body.

            **TODO: What is the syntax for calling a prefix operator's original
            code?**

    1.  Else, if the declaration is a variable:

        1.  Replace a matching variable, getter, and/or setter in the namespace
            with the declaration. Inside the augmenting variable's initializer
            expression, an `augment super` expression invokes the original
            variable initializer.

    **TODO: Expand this to allow enums if [enhanced enums][] are added to
    Dart.**

1.  Else, it is a new declaration in the augmentation library:

    1.  If a declaration with that name already exists in the namespace, error.
        (Exception: setters do not collide with getters and final variables.)

    1.  Else, add the declaration to the namespace.

## Deprecating part files

Part files have been [discouraged for many years][discourage]. They are still
fairly often used by code generators because it gives generated code access to
the main library's private namespace. However, it means that the generated part
file cannot have its own imports.

[discourage]: https://dart.dev/guides/libraries/create-library-packages#organizing-a-library-package

If we support private imports, then augmentation libraries can do everything
part files can do. At that point, we can more strongly recommend the few users
using them migrate to augmentations. In Dart 3.0, we can consider removing
support for part files entirely, which would simplify the language and our
tools.

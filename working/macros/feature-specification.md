# Macros

Authors: Jacob MacDonald, Bob Nystrom

Status: **Work In Progress**

## Introduction

The [motivation][] document explains why we are working on static
metaprogramming. This proposal introduces macros to Dart. A **macro** is a piece
of code that can modify other parts of the program at compile time. A **macro
application** invokes the given macro on the declaration it is applied to. The
macro **introspects** over the declaration it was applied to and based on that
**generates code** to modify the declaration or add new ones.

A **macro declaration** is a user-defined Dart class that implements one or more
new built-in macro interfaces. Macros in Dart are written in normal imperative
Dart code. There is not a separate "macro language".

[motivation]: motivation.md

You can think of macros as exposing functionality similar to existing [code
generation tools][codegen], but integrated more fully into the language.

[codegen]: https://dart.dev/tools/build_runner

### Introspection

Most macros don't simply generate new code from scratch. Instead, they add code
to a library based on existing properties of the program. For example, a macro
that adds JSON serialization to a class might look at the fields the class
declares and from that synthesize a `toJson()` method that serializes those
fields to a JSON object.

This means that when a macro executes, it often **introspects** over some part
of the program to look at its existing structure. A macro can look at the
declaration that it is applied to. For example, a macro applied to a class can
see the class's name, superclasses, members, etc. Some of those properties are
type annotations, like the superclass or the return type of a method. From that
type annotation, the macro may be able to traverse to the declaration that the
annotation refers to. In this way, a macro applied to one part of the program
may ultimately access information about distant parts of the program.

Allowing deep introspection like this in cases where a macro needs it while
ensuring that users can understand the system and tools can implement it
efficiently is a central challenge of this proposal.

### Ordering in metaprogramming

Macros can read the user's Dart program and modify it. They are also written in
Dart as part of the same program. When you have lots of macros all looking at
and modifying the same program while it is in the middle of being compiled, it
can be hard to define a coherent compilation and macro expansion order. Can a
macro body call a method generated by another macro? Does a macro that looks at
the fields on a class see the fields generated by some other macro?

The rest of the proposal addresses these specific ordering challenges in detail,
but the basic principles are:

1.  When possible, macro application order is *not* user-visible. Most macro
    applications are isolated from each other. This makes it easier for users to
    reason about them separately, and gives implementations freedom to evaluate
    (or re-evaluate) them in whatever order is most efficient.

1.  When users apply macros to the *same* portions of the program where the
    ordering is important, they can easily *control* that ordering.

In other words, in cases where you care about the order that macros run, you
should be able to control it to get what you want. And in most other cases, the
system should ensure that you don't have to care.

## Macro applications

Macros are applied to declarations using the existing metadata annotation
syntax. For example:

```dart
@myCoolMacro
class MyClass {}
```

Here, if `myCoolMacro` resolves to an instance of a class implementing one or
more of the macro interfaces, then the annotation is treated as an application
of the `myCoolMacro` macro to the class MyClass.

### Arguments

Macro applications can also be passed arguments. For example:

```dart
int get a => 1;
const b = 2;

class SomeClass {
  @Add(1, a + b)
  int addThem(); // Generates: => 1 + a + b;
}
```

Here, `Add` is a macro that takes its arguments and produces a function body
that adds them using `+` and returns the result.

Because macros are applied at compile time, the arguments are passed to the
macro as objects representing unevaluated pieces of code. Here, the `Add` macro
receives objects that represent the *literal* `1` and *the expression* `a + b`.
It takes those and composes them into a function body like:

```dart
=> 1 + a + b
```

Most of the time, like here, a macro takes the arguments you pass it and
interpolates them back into code that it generates, so passing the arguments as
code is what you want.

### Value arguments

Sometimes, though, the macro wants to receive an actual argument value. For
example, a macro for defining vector classes might take the dimension as an
integer and need to know the actual passed integer value at compile time to know
how many fields to define. To support that, macros can also accept arguments as
values. However, only built-in value types (int, bool, etc.) are allowed and
arguments must be *simple literal expressions*.

**TODO**: Specify the exact allowed types and expressions.

**TODO**: Metadata annotations currently only allow expression arguments. Do we
want to expand this to allow statements or other grammatical constructs?

**TODO**: Should we support const expressions as values, if they can be
evaluated prior to macro expansion?

### Application order

Multiple macros may be applied to the same declaration, or to declarations that
contain one another. For example, you may apply two macros to the same class, or
to a class and a method in the same class. Since those macros may introspect
over the declaration as well as modify it, the order that those macros are
applied can matter.

Fortunately, since they are all applied to the same textual piece of code, the
user can *control* that order. We use syntactic order to control application
order of macros:

*   **Macros are applied to inner declarations before outer ones.** Macros on
    class members are applied before macros on the class, macros on top-level
    declarations are applied before a macro on the entire library, etc.

    **TODO**: Specify this fully.

*   **Macros applied to the same declaration are applied right to left.** For
    example:

    ```dart
    @third
    @second
    @first
    class C {}
    ```

    Here, the macros applied to C are run `first`, `second`, then `third`.

Aside from these rules, macro introspection is limited so that evaluation order
is not user visible. For example, if two macros are applied to two methods in
the same class, there is no way for those macros to interfere with each other
such that the application order can be detected.

## Phases

Before we can get into how macro authors create macros, there is another
ordering problem to discuss. Imagine you have these two classes for tracking
pets and their humans:

```dart
@jsonSerializable
class Human {
  final String name;
  final Pet? pet; // Optional, might not have a pet.
}

@jsonSerializable
class Pet {
  final String name;
  final Owner? owner; // Optional, might be feral.
}
```

You want to be able to save these to the cloud, so you use a `@jsonSerializable`
macro that generates a `toJson()` method on each class the macro is applied to.
You want the methods to look like this:

```dart
class Human {
  ...
  Map<String, Object?> toJson() => {
    'name': name,
    'pet': pet?.toJson(),
  };
}

class Pet {
  ...
  Map<String, Object?> toJson() => {
    'name': name,
    'owner': owner?.toJson(),
  };
}
```

Note that the `pet` and `owner` fields are serialized by recursively calling
their `toJson()` methods. To generate that code, the `@jsonSerializable` macro
needs to look at the type of each field to see if it declares a `toJson()`
method. The problem is that there is *no* order of macro application that will
give the right result. If we apply `@jsonSerializable` to Human first, then it
won't call `toJson()` on `pet` because Pet doesn't have a `toJson()` method yet.
We get the opposite problem if we apply the macro to Pet first.

To address this, macros execute in **phases.** Earlier phases declare new types
and declarations while later phases fill them in. This way, we can declare the
existence of *all* of the `toJson()` methods in the above example before
generating the *bodies* of any of those `toJson()` methods where we need to
introspect over the fields.

In each phase, macros only have access to the parts of the program that are
already complete. This ensures that the evaluation order of unrelated macro
applications is not user visible. Each phase produces information accessible to
later phases. As the program is incrementally "pinned down", later phases gain
more introspective power, but have less power to mutate the program.

There are three phases:

### Phase 1: Types

Here, macros contribute new types to the program&mdash;classes, typedefs, enums,
etc. This is the only phase where a macro can introduce a new visible name into
the top level scope.

Very little introspective power is provided in this phase. Since other macros
may also be declaring new types, we can't even assume that all top-level
identifiers can be resolved. You can see the *names* of types that are
referenced in the declaration the macro is applied to, but you can't ask if they
are a subtype of a known type. Type hierarchies have not been resolved yet. Even
a type which could be resolved to an existing type might not actually resolve to
that type once macros are done (a new type could be introduced which shadows the
original one).

After this phase completes, all top-level names are declared. Subsequent phases
know exactly which type any named reference resolves to, and can ask questions
about subtype relations.

### Phase 2: Declarations

In this phase, macros declare functions, variables, and members. "Declaring"
here means specifying the name and type signature, but not the body of a
function or initializer for a variable. In other words, macros in this phase
specify the declarative structure but no imperative code.

When applied to a class, a macro in this phase can introspect on all of the
members of that class and its superclasses, but it cannot introspect on the
members of other types.

### Phase 3: Definitions

In the final phase, macros provide the imperative code to fill in abstract or
external members. Macros in this phase can also wrap existing methods or
constructors, by injecting some code before and/or after those method bodies.
These statements share a scope with each other, but not with the original
function body.

Phase three macros can add new supporting declarations to the surrounding scope,
but these are private to the macro generated code, and never show up in
introspection APIs. These macros can fully introspect on any type reachable from
the declarations they are applied to, including introspecting on members of
classes, etc.

## Macro definitions

Macro definitions do not have any unique syntax or language features. They are
regular Dart class declarations. They are macros by virtue of the fact that they
implement one or more special "macro" interfaces defined by the Dart core
libraries.

Every macro interface is a subtype of a root [Macro][] type. There are
interfaces for each kind of declaration macros can be applied to: class,
function, etc. Then, for each of those, there is an interface for each macro
phase: type, declaration, and definition.

[Macro]: https://jakemac53.github.io/macro_prototype/doc/api/definition/Macro-class.html

A single macro class can implement as many of these interfaces as it wants to.
This can allow a single macro to participate in multiple phases and to support
being applied to multiple kinds of declarations.

The full API is still being designed, and is documented [here][docs]. Here are
some direct links to the root interfaces for each phase:

[docs]: https://jakemac53.github.io/macro_prototype/doc/api/definition/definition-library.html
- [TypeMacro][]
- [DeclarationMacro][]
- [DefinitionMacro][]

[TypeMacro]: https://jakemac53.github.io/macro_prototype/doc/api/definition/TypeMacro-class.html
[DeclarationMacro]: https://jakemac53.github.io/macro_prototype/doc/api/definition/DeclarationMacro-class.html
[DefinitionMacro]: https://jakemac53.github.io/macro_prototype/doc/api/definition/DefinitionMacro-class.html

For example, the interface you should implement for a macro that runs on classes
in the declaration phase is [ClassDeclarationMacro][].

[ClassDeclarationMacro]: https://jakemac53.github.io/macro_prototype/doc/api/definition/ClassDeclarationMacro-class.html

### Introspection API

The first argument to any method that you implement in your macro is the
introspection object. This is a representation of the declaration that the macro
was applied to.

For example, lets look at the [ClassDeclarationMacro][] API, which has the
following method that you must override:

```dart
class ClassDeclarationMacro implements DeclarationMacro {
  void visitClassDeclaration(
      ClassDeclaration declaration, ClassDeclarationBuilder builder);
}
```

The [ClassDeclaration][] instance you get here provides all the
introspective information to you that is available for classes in the
`declaration` phase.

[ClassDeclaration]: https://jakemac53.github.io/macro_prototype/doc/api/definition/ClassDeclaration-class.html

The `builder` parameter also provides an API that allows you to retrieve an
introspection object for any `Type` object available to the macro at runtime.
The introspection capabilites of these objects are limited to the information
produced by the previous macro phase of macros, similar to the capabilites
provided for type references on the declaration.

### Metadata annotations

**TODO**: Introduce this from the perspective of the application, not the
declaration.

Macros may want introspect on metadata annotations on declarations to control
their behavior. For instance a class level macro may want to expose some
per-declaration control over their output, and annotations are an intuitive
way to provide that.

#### The annotation introspection API

We could try to give users access to an actual instance of the annotation, or
we could give something more like the [DartObject][] class from the analyzer.

[DartObject]: https://pub.dev/documentation/analyzer/latest/dart_constant_value/DartObject-class.html

Since annotations may contain references to types or identifiers that the macro
does not import, we choose to expose a more abstract API (similar to
[DartObject][]).

**TODO**: Define the exact API.

#### Annotations that require macro expansion

This could happen if the annotation class has macros applied to it, or if
some argument(s) to the annotation constructor use macros.

Because macros are not allowed to generate code that shadows an identifier
in the same library, we know that if an annotation class or any arguments to it
could be resolved, then we can assume that resolution is correct.

This allows us to provide an API for macro authors to attempt to evaluate an
annotation in _any phase_. The API may fail (if it requires more macro
expansion to be done), but that is not expected to be a common situation. In
the case where it does fail, users should typically be able to move some of
their code to a separate library (which they import). Then things from that
library can safely be used in annotations in the current library, and evaluated
by macros.

Evaluation must fail if there are any macros left to be expanded on the
annotation class or any arguments to the annotation constructor.

#### Are macro applications introspectable?

Macro applications share the same syntax as annotations, and users may expect
macros to be able to see the other macros as a result.

For now we are choosing not to expose other macro applications as if they were
metadata. While they do share a syntax they are conceptually different.

#### Modifying metadata annotations

We will not allow modification or removal of existing annotations, in the same
way that we do not allow modification or removal of existing code.

However, there are potentially situations where it would be useful for a macro
to be able to add metadata annotations to existing declarations. These would
then be read in by other macros (or the same macro in a later phase). In
particular this may be useful when composing multiple macros together into a
single macro. That macro may have a different configuration annotation that it
uses, which it then splits up into the specific annotations that the other
macros it uses expect.

However, if we aren't careful then allowing adding metadata in this way would
expose the order in which macros are applied. For this reason metadata which is
added in this way is not visible to any other macros ran in the same phase.

This does have two interesting and possibly unexpected consequences:

- Macros may see different annotations on the same declaration, if they run in
  different phases.
- Metadata on entirely new declarations is visible in the same phase, but
  metadata added to existing declarations is only visible in later phases.

**TODO**: Define the API for adding metadata to existing declarations.

## Generating code

At the root of the API for generating code, are the [Code][] and `*Builder`
classes.

[Code]: https://jakemac53.github.io/macro_prototype/doc/api/definition/Code-class.html

- The [Code][] class and its subtypes are first-class representations of
  pieces of Dart programs, essentially abstract syntax trees.
- The `*Builder` instance is always passed as the second argument to the methods
  you implement in your macro, and is what you use to actually augment the
  program with [Code][].

There is a different type of `*Builder` for each specific type of macro, for
instance if you look at the [DeclarationBuilder][] class, you will see this
interface method `void addToLibrary(Declaration declaration)`. The
[Declaration][] class here is a subtype of [Code][].

[Declaration]: https://jakemac53.github.io/macro_prototype/doc/api/definition/Declaration-class.html
[DeclarationBuilder]: https://jakemac53.github.io/macro_prototype/doc/api/definition/DeclarationBuilder-class.html

Most subtypes of [Code][] require fully syntactically valid code in order to
be constructed, but where you need to build up something in smaller pieces you
can use the [Fragment][] subtype. Any arbitrary String can be passed to this
class, allowing you to build up your code fragments however you like.

[Fragment]: https://jakemac53.github.io/macro_prototype/doc/api/definition/Fragment-class.html

### Adding new macro applications

Macros are allowed to add new macro applications in two ways:

#### Adding macro applications to new declarations

When creating [Code][] instances, a macro may generate code which includes
macro applications. These macro applications must be from either the current
phase or a later phase, but cannot be from previous phases.

If a macro application is added which implements an earlier phase, that phase
is not ran. This should result in a warning if the macro does not also
implement some phase that will be ran.

If a macro application is added which runs in the same phase as the current
one, then it is immediately expanded after execution of the current macro,
following the normal ordering rules.

#### Adding macro applications to existing declarations

Macro applications can be added to existing declarations through the `*Builder`
APIs. Macros added in this way are always prepended to the list of existing
macros on the declaration (which makes them run _last_).

Note that macros can already _immediately_ invoke another macro on a given
declaration manually, by simply instantiating the macro and then invoking
it.

**TODO**: Update the builder APIs to allow this.

#### Note about ordering violations

Note that both of these mechanisms allow for normal macro ordering to be
circumvented. Consider the following example, where all macros run in the
Declaration phase:

```dart
@macroA
@macroB
class X {
  @macroC // Added by `@macroA`, runs after both `@macroB` and `@macroA`
  int? a;

  // Generated by `@macroC`, not visible to `@macroB`.
  int? b;
}
```

Normally, macros always run "inside-out". But in this case `@macroC` runs after
both `@macroB` and `@macroC` which were applied to the class.

We still allow this because it doesn't cause any ambiguity in ordering, even
though it violates the normal rules.

We could instead only allow adding macros from _later_ phases, but that would
restrict the functionality in unnecessary ways.

### Scoping

#### Resolved identifiers

Macros will likely want to introduce references to identifiers that are not in
the scope of the library in which they are running, but are in the scope of the
macro itself, or possibly even references which are not in scope of either the
macro itself or the library where it is applied.

Even if an identifier is in scope of the library in which the macro is applied
(lets say its exported by the macro library), that identifier could be shadowed
by another identifier in the library.

**TODO**: Investigate other approaches to the proposal below, see discussion
at https://github.com/dart-lang/language/pull/1779#discussion_r683843130.

To enable a macro to safely emit a reference to a known identifier, there is
a `Identifier` subtype of `Code`. This class takes both a simple name for the
identifier (no prefix allowed), as well as a library URI, where that identifier
should be looked up.

The generated code should be equivalent to adding a new import to the library,
with the specified URI and a unique prefix. In the code the identifier will be
emitted with that unique prefix followed by its simple name.

Note that technically this allows macros to add references to libraries that
the macro itself does not depend on, and the users application also may not
depend on. This is discouraged, but not prevented, and should result in an error
if it happens.

#### Generated declarations

A key use of macros is to generate new declarations, and handwritten code may
refer to them—it may call macro-generated functions, read macro-generated
fields, construct macro-generated classes, etc. This means that before macros
are applied, code may contain identifiers that cannot be resolved. This is not
an error. Any identifier that can't be resolved before the macro is applied is
allowed to be resolved to a macro-produced identifier after macros are applied.

All the rules below apply only to the library in which a macro is applied—macro
applications in imported libraries are considered to be fully expanded already
and are treated exactly the same as handwritten code.

Macros are not permitted to introduce declarations that directly conflict with
existing declarations in the same library. These rules are the same as if the
code were handwritten.

Macros may also add declarations which shadow existing symbols in the library,
but don't directly conflict. In this case we want to ensure that the intent of
any user written code is always clear. Consider the following example:

```dart
int get x => 1;

@generateX
class Bar {
  // Generated: int get x => 2;

  // Should this return the top level `x`, or the generated instance getter?
  int get y => x;
}
```

There are several potential choices to we could make here:

1.  We could say that any identifier that can be resolved before macro
    application keeps its original resolution (so `x` would still resolve to the
    original, top level `x`).
2.  We could re-resolve all identifiers after the macros are applied, which can
    possibly change what they resolve to (in this case `x` would resolve to the
    generated instance getter `x`).
3.  We could make it some kind of error for a macro to introduce an identifier
    that shadows another.
4.  We could make it a compile-time error to *use* an identifier shadowed by one
    produced by a macro.

The first two choices could be very confusing to users, some will expect one
behavior while others expect the other. The third choice would work but might be
overly restrictive. The final option still avoids the ambiguity, and is a bit
more permissive than the third.

It similarly also is not allowed for one macro to produce a declaration that the
identifier resolves to and then another macro to produce another declaration
that then shadows that one. In other words, any hand-authored identifier may be
resolved at any point during macro application, but it may only be resolved
once.

These constraints produce this rule:

*   It is a compile-time error if any hand-authored identifier in a library
    containing a macro application would bind to a different declaration when
    resolved before and after macro expansion in that library. In other words,
    it is a compile-time error if a macro introduces an identifier that shadows
    a handwritten identifier that is used in the same library.

This follows from the general principle that macros should not alter the
meaning of existing code. Adding the getter `x` in the example above shadows the
top level `x`, changing the meaning of the original code.

Note, that if the getter were written as `int get y => this.x;`, then a macro
*would* be allowed to introduce the new getter `x`, because `this.x` could not
previously be resolved.

## Compiling macros

**TODO**: Explain library cycles and compiling to library augmentations.

### Macro compilation order

Applying a macro involves executing the Dart code inside the body of the macro.
Obviously, that code must be type-checked and compiled before it can be run. To
ensure that the code defining the macro can be compiled before it's applied, we
have the following restrictions:

*   **A macro cannot be applied in the same library where it is defined.** The
    macro must always be defined in some other library that you import into the
    library where it is applied. This way, the library where the macro is
    defined can be compiled first.

*   **There must be no import path from the library where a macro is defined to
    any library where it is used.** Since the library applying the macro *must*
    import the definition, this is another way of saying that there can't be any
    cyclic imports (directly or indirectly) between the library where a macro is
    defined and any library where it is used. This ensures that we can reliably
    compile the library where the macro is defined first because it doesn't
    depend on any of the libraries using the macro.

**TODO: Instead of the above rules, we are considering a more formal notion of
"[modules]" or "library groups" to enforce this acyclicity.**

[modules]: https://github.com/dart-lang/language/tree/master/working/modules

### Complete macro application order

When all of these are put together, an idealized compilation and macro
application of a Dart program looks like this:

**TODO**: Update to use library cycles.

1.  For each library, ordered topologically by imports:

    1.  For each declaration, with nested declarations ordered first:

        1.  Apply each phase 1 macro to the declaration, from right to left.

    1.  At this point, all top level identifiers can be resolved.

    1.  For each declaration, with nested declarations ordered first:

        1.  Apply each phase 2 macro to the declaration, from right to left.

    1.  At this point, all declarations and their signatures exist. The library
        can be type checked.

    1.  For each declaration, with nested declarations ordered first:

        1.  Apply each phase 3 macro to the declaration, from right to left.

    1.  Now all macros have been applied, all imperative code exists, and the
        library can be completely compiled. Any macros defined in this library
        are ready to be used by later libraries.

## Executing macros

To apply a macro, a Dart compiler constructs an instance of the applied macro's
class and then invokes methods on it that implement the macro API. The arguments
in the metadata annotation for the macro application are passed to the macro as
constructor parameters.

The macro choose whether an argument is passed by value or as an unevaluated
expression through the corresponding parameter type. If the parameter's type is
[Code][] (or any subtype of it), the argument is passed unevaluated. If it is a
primitive type, the argument is passed by value. It is a compile-time error if a
macro class's constructor has a parameter type that is not a subtype of Code or
one of the allowed value types.

**TODO**: Specify the allowed types.

**Note**: A Dart implementation implicitly converts the macro argument
expression to a Code object ("lifts" the expression to a "metaobject")
implicitly as part of macro application. This only happens when executing actual
macro applications at compile time. If a Dart program invokes a macro class's
constructor explicitly&mdash;for example, when writing tests of the
macro&mdash;then it is up to the caller to explicitly create the Code object.

### Execution environment

The execution environment for macros is different from that of normal code.
Specifically, we have some semantics that we want to uphold (to the extent
that is feasible) which puts some constraints on the environment.

- No direct access to the host device (except through the `Resource` API).
- No ability to spawn arbitrary processes or isolates.
- The ordering of macros in the same phase should not be observable.
- Macros should always generate the same code, regardless of host environment,
  target environment, or non-file based configuration.
  - This means no access to system environment variables, Dart environment
    variables (-D defines), command line arguments, or other such configuration.
  - The "host environment" here refers to the environment in which the macro
    itself is running.

These general principles are what drives the various requirements for the
execution environment in which macros run.

### Access to core libraries

Only the core libraries which don't violate the above rules are allowed, the
full list of _allowed_ core libraries is as follows:

- `dart:async`
- `dart:collection`
- `dart:convert`
- `dart:core`
- `dart:math`
- `dart:typed_data`

All other SDK libraries are not available.

### Side effects

Macros should not be able to observe the order in which they are ran with
respect to other macros in the same phase. If macros touch shared global state
then they would be able to observe the ordering, and may rely on that ordering
in ways that get broken by future changes or are generally unstable.

There are several possible approaches to this problem that are being considered:

1. Don't allow macro code to mutate global state at all.
    - This is probably overly-restrictive, and may be hard to enforce. There are
      some legitimate cases in library code (`package:logging` as an example).
2. Run each macro application in a completely new isolate.
    - Good from a semantics and flexibility perspective, but may be too slow.
3. Reset all static state between macro invocations.
    - Good option if it is feasible on the tooling side of things and it can be
      fast.
4. Document mutating global state as a bad practice, but don't block it. Give no
   guarantees around static state persistance between macro applications.
    - In practice this would likely be fine, but it isn't ideal. Some authors
      are likely to exploit this in weird ways, and we could get stuck
      maintaining behavior that we don't want to.
    - Would likely be the most performant solution, global objects would be
      shared across macro applications instead of being re-instantiated for
      each.
    - Also the easiest solution, no work required.

**TODO**: Choose a solution.

### Platform specific semantics

Macros may execute in different environments which have different semantics than
than the target environment, for instance in the case of numbers. Macros are
executed with the normal semantics of the host environment, whatever those are.

- **Note**: This is a violation of the rule that macros should always generate
  the same code regardless of the host environment.

Macros do not have visibility into the target environment, and they can only
detect the host environment using existing mechanisms (`0 is double` style
checks).

This means that code which executes inside a macro may have a different result
than the same code executed at runtime, if the environments are different.

### Dart environment variables

Macros _do not_ have access to the Dart environment variables, and all
`fromEnvironment` constructors will return the default values.

While it could be useful for macros to read environment variables it would
be very problematic for development tools to deal with. Having a single,
consistent version of generated code is more predictable for both tools and
users.

### System environment variables

Macros _do not_ have access to the system environment variables, since they do
not have access to `dart:io` where they are exposed.

## Language and API evolution

### Language versioning

Macros generate code directly into existing libraries, and we want to maintain
the behavior that a library only has one language version. Thus, the language
version of macro generated code is always that of the library it is generating
code _into_.

This means that macros need the ability to ask for the language version of a
given library. This will be allowed through the library introspection class,
which is available from the introspection APIs on all declarations via a
`library` getter.

**TODO**: Fully define the library introspection API for each phase.

### API versioning

**TODO**: Finalize the approach here.

It is possible that future language changes would require a breaking change to
an existing imperative macro API. For instance you could consider what would
happen if we added multiple return values from functions. That would
necessitate a change to many APIs so that they would support multiple return
types instead of a single one.

#### Proposal: Ship macro APIs as a Pub package

Likely, this package would only export directly an existing `dart:` uri, but
it would be able to be versioned like a public package, including tight sdk
constraints (likely on minor version ranges). This would work similar to the
`dart:_internal` library.

This approach would involve more work on our end (to release this package with
each dart release). But it would help keep users on the rails, and give us a
lot of flexibility with the API going forward.

## Resources

Some macros may wish to load resources (such as files). We do want to enable
this, but because macros are untrusted code that runs at analysis time, we
block macros from reading resources outside the scope of the original program.

In order to distinguish whether a resource is "in scope", we use the package
config file. Specifically, we allow access to any resource that exists under
the root URI of any package in the current package config. Note that this may
include resources outside of the `lib` directory of a package - even for
package dependencies - depending on how the package config file is configured.

If the URI points to a symlink it must be followed and the final physical file
location checked to be a valid path under a package root. Otherwise they could
be used to circumvent this check and load a resource that is outside the scope
of the program.

**TODO**: Evaluate whether this restriction is problematic for any current
compilation strategies, such as in bazel, and if so consider alternatives.

Resources are read via a [Uri][]. This may be a `package:` URI, or an absolute
URI of any other form as long as it exists under the root URI of some package
listed in the package config.

[Uri]: https://api.dart.dev/stable/2.13.4/dart-core/Uri-class.html

It is also intuitive for macros to accept a relative URI for resources. In
order to support this macros should compute the absolute URI from the current
libraries URI. This URI is accessible by introspecting on the library of the
declaration that a macro is applied to.

**TODO**: Support for relative URIs in part files (requires a part file
  abstraction)?

**TODO**: Should libraries report their fully resolved URI or the URI that was
used to import them? The latter would mean that files under `lib` could not read
resources outside of `lib`, which has both benefits and drawbacks.

Lastly, since macros must return synchronously, we only expose a synchronous
API for reading resources.

The specific API is as follows, and would only be available at compile time:

```dart
/// A read-only resource API for use in macro implementation code.
class Resource {
  /// Either a `package:` URI, or an absolute URI which is under the root of
  /// one or more packages in the current package config.
  final Uri uri;

  /// Creates a resource reference.
  ///
  /// The [uri] must be valid for this compilation, which means that it exists
  /// under the root URI of one or more packages in the package config file.
  ///
  /// Throws an [InvalidResourceException] if [uri] is not valid.
  Resource(this.uri);

  /// Whether or not a resource actually exists at [uri].
  bool get exists;

  /// Synchronously reads this resource as bytes.
  Uint8List readAsBytesSync();

  /// Synchronously reads this resource as text using [encoding].
  String readAsStringSync({Encoding encoding = utf8});

  /// Synchronously reads the resource as lines of text using [encoding].
  List<String> readAsLinesSync({Encoding encoding = utf8});
}
```

### Resource invalidation

Resources that are read should be treated as source inputs to the program, and
should invalidate the parts of the program that depended on them when they
change.

When a resource is read during compilation, it should either be cached for
subsequent reads to use or a hash of its contents stored. No two macros should
ever see different contents for the same resource, within the same build.

This implies that the compilers will need to be keeping track of which
resources have been read, and adding a dependency on those resources to the
library. The compilers (or tools invoking the compilers) will then need to
watch these resource files for changes in the same way that they watch source
files today.

This also includes tracking when resources are created or destroyed - so for
instance calling any method on a `Resource` should add a dependency on the
`uri` of that resource, whether it exists or not.

#### build_runner

In build_runner we run the compiler in a special directory and we only copy
over the files we know will be read (transitive dart files). How would we
know which resources to copy over, and more specifically which resources were
read by the compiler?

It is likely that we would need some special configuration from the users here
to make this work, at least a general glob of available resources for a package.

#### bazel

No additional complications, resources will need to be provided as data inputs
to the dart_library targets though.

#### frontend_server

The frontend server will need to communicate back the list of resources that
were depended on. This could likely work similarly to how it reports changes
to the Dart sources (probably just treat them in the same way as source files).

## Limitations

- Macros cannot be applied from within the same library cycle as they are
  defined.

- Macros cannot write arbitrary files to disk, and read them in later. They
  can only generate code into the library where they are applied.
  - **TODO**: Full list of available `dart:` APIs.
  - **TODO**: Design a safe API for read-only access to files.

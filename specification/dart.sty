\def\builtinId#1{\textsf{\textbf{#1}}}
\def\keyword#1{\textsf{\textbf{#1}}}
\def\metavar#1{\ensuremath{\mathit{#1}}}

\def\ABSTRACT{\builtinId{abstract}}
\def\AS{\builtinId{as}}
\def\COVARIANT{\builtinId{covariant}}
\def\DEFERRED{\builtinId{deferred}}
\def\DYNAMIC{\builtinId{dynamic}}
\def\EXPORT{\builtinId{export}}
\def\EXTERNAL{\builtinId{external}}
\def\EXTENSION{\builtinId{extension}}
\def\FACTORY{\builtinId{factory}}
\def\FUNCTION{\builtinId{Function}}
\def\GET{\builtinId{get}}
\def\IMPLEMENTS{\builtinId{implements}}
\def\IMPORT{\builtinId{import}}
\def\INTERFACE{\builtinId{interface}}
\def\LIBRARY{\builtinId{library}}
\def\MIXIN{\builtinId{mixin}}
\def\OPERATOR{\builtinId{operator}}
\def\PART{\builtinId{part}}
\def\REQUIRED{\builtinId{required}}
\def\SET{\builtinId{set}}
\def\STATIC{\builtinId{static}}
\def\TYPEDEF{\builtinId{typedef}}

\def\ASSERT{\keyword{assert}}
\def\ASYNC{\keyword{async}}
\def\AWAIT{\keyword{await}}
\def\BREAK{\keyword{break}}
\def\CASE{\keyword{case}}
\def\CATCH{\keyword{catch}}
\def\CLASS{\keyword{class}}
\def\CONST{\keyword{const}}
\def\CONTINUE{\keyword{continue}}
\def\DEFAULT{\keyword{default}}
\def\DO{\keyword{do}}
\def\ELSE{\keyword{else}}
\def\ENUM{\keyword{enum}}
\def\EXTENDS{\keyword{extends}}
\def\FALSE{\keyword{false}}
\def\FINAL{\keyword{final}}
\def\FINALLY{\keyword{finally}}
\def\FOR{\keyword{for}}
\def\HIDE{\keyword{hide}}
\def\IF{\keyword{if}}
\def\IN{\keyword{in}}
\def\IS{\keyword{is}}
\def\LATE{\keyword{late}}
\def\NEW{\keyword{new}}
\def\NULL{\keyword{null}}
\def\OF{\keyword{of}}
\def\ON{\keyword{on}}
\def\RETHROW{\keyword{rethrow}}
\def\RETURN{\keyword{return}}
\def\SHOW{\keyword{show}}
\def\SUPER{\keyword{super}}
\def\SWITCH{\keyword{switch}}
\def\SYNC{\keyword{sync}}
\def\THIS{\keyword{this}}
\def\THROW{\keyword{throw}}
\def\TRUE{\keyword{true}}
\def\TRY{\keyword{try}}
\def\TYPE{\keyword{type}}
\def\VAR{\keyword{var}}
\def\VOID{\keyword{void}}
\def\WHILE{\keyword{while}}
\def\WITH{\keyword{with}}
\def\YIELD{\keyword{yield}}

% Used for inline code snippets.
\newcommand{\code}[1]{\texttt{#1}}

% Used to specify syntactic sugar.
\def\LET{\keyword{let}}
\newcommand{\Let}[3]{\code{\LET\,\,{#1}\,=\,{#2}\ \IN\ {#3}}}
\newcommand{\LetTwo}[5]{%
  \code{\LET\,\,{#1}\,=\,{#2},\ {#3}\,=\,{#4}\ \IN\ {#5}}}
\newcommand{\LetThree}[7]{%
  \code{\LET\,\,{#1}\,=\,{#2},\ {#3}\,=\,{#4},\ {#5}\,=\,{#6}\ \IN\ {#7}}}
\newcommand{\LetMany}[5]{%
  \code{\LET\,\,{#1}\,=\,{#2},\ $\cdots$,\ {#3}\,=\,{#4}\ \IN\ {#5}}}

% Used for inline meta-code snippets
\newcommand{\metaCode}[1]{{\color{metaColor}\texttt{#1}}}

% `call` has no special lexical status, so we just use \code{}.
\def\CALL{\code{call}}

% Define commands for `<<`, `>>`, `>>>` that avoid introducing guillemets.
\def\ltlt{<\mbox <}
\def\gtgt{>\mbox >}
\def\gtgtgt{>\mbox >\mbox >}

% Commands for single quotes, enabling them to be used
% in a `grammar` environment.
\def\sq{\mbox'}
\def\sqsq{\mbox{'{}'}}
\def\sqsqsq{\mbox{'{}'{}'}}

% Used as line break in the right hand side of a grammar
% alternative, that is, when starting a "continuation line".
\newcommand{\gnewline}{\leavevmode\\}

% Used in lexical grammar rules to express negation of a character or
% character set (which simply denotes the set of all other characters);
% also used to show the actual "tilde" character as source code.
\newcommand{\gtilde}{\mbox{\code{\textasciitilde}}}

% Metavariables for argument lists.
\newcommand{\argumentList}[1]{\metavar{{#1}s}}
\newcommand{\parameterList}[1]{\metavar{{#1}s}}

% Colors used for for different kinds of text.
\definecolor{normativeColor}{rgb}{0,0,0}
\definecolor{commentaryColor}{rgb}{0.5,0.5,0.5}
\definecolor{rationaleColor}{rgb}{0.5,0.5,0.5}
\definecolor{metaColor}{rgb}{0,0,1}

% Environments for different kinds of text.
\newenvironment{Q}[1]{{\bf{}Upcoming: {#1}}}{}
\newenvironment{rationale}[1]{{\color{rationaleColor}\it{#1}}}{}
\newenvironment{commentary}[1]{{\color{commentaryColor}\sf{#1}}}{}

% Auxiliary functions.
\newcommand{\flattenName}{\metavar{flatten}}
\newcommand{\flatten}[1]{\ensuremath{\flattenName({#1})}}
\newcommand{\futureOrBase}[1]{\ensuremath{\metavar{futureOrBase}({#1})}}
\newcommand{\overrides}[1]{\ensuremath{\metavar{overrides}({#1})}}
\newcommand{\inherited}[1]{\ensuremath{\metavar{inherited}({#1})}}

% Used as a mini-section marker, indicating visibly that a range of
% text (usually just a couple of paragraphs) are concerned with one
% specific topic in a list of similar topics (like many forms of
% expressions of a similar nature).
\newcommand{\Case}[1]{\textbf{Case }$\langle\hspace{0.1em}${#1}$\hspace{0.1em}\rangle$\textbf{.}}
\newcommand{\EndCase}{\mbox{}\hfill$\scriptscriptstyle\Box$\xspace}

% Used for source code examples.
\newenvironment{dartCode}[1][!ht]{%
  \def\@programcr{\@addfield\strut}%
  \let\\=\@programcr%
  \relax\@vobeyspaces\obeylines%
  \ttfamily\color{commentaryColor}%
  \vspace{1em}%
}{\normalcolor\vspace{1em}}

% Used for normative code snippets (mainly desugaring).
\newenvironment{normativeDartCode}[1][!ht]{%
  \def\@programcr{\@addfield\strut}%
  \let\\=\@programcr%
  \relax\@vobeyspaces\obeylines%
  \ttfamily\color{normativeColor}%
  \vspace{1em}%
}{\normalcolor\vspace{1em}}

% Used for meta-level code, such as the code transformations used
% to specify the semantics of "null shorting" in expressions like
% `a?.b.c`.
\newenvironment{metaLevelCode}[1][!ht]{%
  \def\@programcr{\@addfield\strut}%
  \let\\=\@programcr%
  \relax\@vobeyspaces\obeylines%
  \ttfamily\color{metaColor}%
  \vspace{1em}%
}{\normalcolor\vspace{1em}}

% Used for comments in a code context.
\def\comment#1{\textsf{#1}}

% A commonly used metavariable for an identifier, operator.
\newcommand{\id}{\metavar{id}}
\newcommand{\op}{\metavar{op}}

% Used for defining occurrence of phrase, with customized index entry.
\newcommand{\IndexCustom}[2]{%
  \leavevmode\marginpar{\ensuremath{\vartriangle}}\emph{#1}\index{#2}}

% Used for the defining occurrence of a local symbol.
\newcommand{\DefineSymbol}[1]{%
  \leavevmode\marginpar{\textcolor{black}{\ensuremath{#1}}}\ensuremath{#1}}

% Used to indicate a defining occurrence of a local symbol without
% typesetting that symbol.
\newcommand{\BlindDefineSymbol}[1]{%
  \leavevmode\marginpar{\textcolor{black}{\ensuremath{#1}}}}

% Used when one concept should have >1 entry in the index. Does not add
% the diamond in the margin and shows no text where the command occurs.
% Intended to be used immediately after another \Index... command.
\newcommand{\IndexExtraEntry}[1]{\index{#1}}

% Used for a defining occurrence of a phrase, adding it to the index.
\newcommand{\Index}[1]{\IndexCustom{#1}{#1}}

% Same appearance, but not adding an entry to the index.
\newcommand{\NoIndex}[1]{%
  \leavevmode\marginpar{\ensuremath{\vartriangle}}\emph{#1}}

% Mark a compile-time error in the margin.
\newcommand{\Error}[1]{%
  \leavevmode\marginpar{\ensuremath{\textcolor{red}{\ominus}}}{#1}}

% Mark a dynamic error in the margin.
\newcommand{\DynamicError}[1]{%
  \leavevmode\marginpar{\textcolor{red}{\Lightning}}{#1}}

% Used to specify comma separated lists of similar symbols.
\newcommand{\List}[3]{\ensuremath{{#1}_{#2},\,\ldots,\ {#1}_{#3}}}

% Used to specify comma separated lists of pairs of similar symbols,
% as needed, e.g., for declarations of formal parameters.
% Parameters: Name of first part of pair, name of second part,
% index at start, index at end.
\newcommand{\PairList}[4]{\ensuremath{%
  {#1}_{#3}\ {#2}_{#3},\,\ldots,\ {#1}_{#4}\ {#2}_{#4}}}

% A sequence of labeled arguments with the same label and expression,
% only differing by subscript.
% Parameters: Argument label, argument expression, start index,
% end index.
%
% For example, \NamedArgumentList{n}{e}{1}{k} yields approximately
% "n1: e1, n2: e2, ... nk: ek".
\newcommand{\NamedArgumentList}[4]{\PairList{#1}{\!\!:\,\,{#2}}{#3}{#4}}

% A sequence of unlabeled and labeled arguments with the same expression and
% (for all labeled arguments) the same label, only differing by subscript.
% Parameters: Argument name, number of positional arguments, labeled parameter
% label, number of labeled arguments.
%
% For example, \ArgumentList{a}{n}{x}{k} yields approximately
% "a1, .. an, xn+1: an+1, .. xn+k: an+k".
\newcommand{\ArgumentList}[4]{%
  \List{#1}{1}{#2},\ \NamedArgumentList{#3}{#1}{{#2}+1}{{#2}+{#4}}}

% Used to specify a standard argument list, that is, an argument list
% which uses the symbols that we prefer to use for that purpose
% whenever possible.
%
% Approximately "a1 .. an, xn+1: an+1 .. xn+k: an+k".
\newcommand{\ArgumentListStd}{\ArgumentList{a}{n}{x}{k}}

% Used to specify a standard type argument list, that is, a type
% argument list which uses the symbols we prefer to use for that
% purpose whenever possible.
%
% Approximately "A1 .. Ar".
\newcommand{\TypeArgumentListStd}{\List{A}{1}{r}}

% Used to specify a list of tuples of the form $(K_j, V_j)$ which are
% used with collection literals.
\newcommand{\KeyValueTypeList}[4]{\ensuremath{%
  ({#1}_{#3},\,{#2}_{#3}),\,\ldots,\ ({#1}_{#4},\,{#2}_{#4})}}

% Used to specify a list of key/value pairs of the form $k_j: v_j$ which are
% used for the semantics of collection literals.
\newcommand{\KeyValueList}[4]{\ensuremath{%
  {#1}_{#3}:\,{#2}_{#3},\,\ldots,\ {#1}_{#4}:\,{#2}_{#4}}}

% Used to specify comma separated lists of triples of similar symbols,
% as needed, e.g., for declarations of formal parameters with defaults.
% Parameters: Name of first part of triple, name of second part,
% name of third part, index at start, index at end.
\newcommand{\TripleList}[5]{\ensuremath{%
  {#1}_{#4}\ {#2}_{#4}\ {#3}_{#4},\,\ldots,\ {#1}_{#5}\ {#2}_{#5}\ {#3}_{#5}}}

% Used to abbreviate \EXTENDS{} in function types.
\newcommand{\FunctionTypeExtends}{\ensuremath{\triangleleft}}

% Used to specify comma separated lists of pairs of symbols
% separated by \EXTENDS{}, as needed for type parameter declarations.
% Parameters: Type parameter name, bound name, number of type parameters.
\newcommand{\TypeParameters}[3]{\ensuremath{%
  {#1}_1\,\EXTENDS\,{#2}_1,\,\ldots,\ %
  {#1}_{#3}\,\EXTENDS\,{#2}_{#3}}}

% Used to specify comma separated lists of symbols followed by
% \EXTENDS{}, as needed for type parameter declarations where we do
% not intend to refer explicitly to the bounds.
% Parameters: Type parameter name, number of type parameters.
\newcommand{\TypeParametersNoBounds}[2]{\ensuremath{%
  {#1}_1\,\EXTENDS\,\ldots,\ \ldots,\ {#1}_{#2}\,\EXTENDS\,\ldots}}

% Used to specify a standard type parameter list, that is, a type
% parameter declaration list which uses the symbols we prefer to use
% for that purpose whenever possible.
%
% Approximately "X1 extends B1, .. Xs extends Bs".
\newcommand{\TypeParametersStd}{\TypeParameters{X}{B}{s}}

% Used to specify comma separated lists of pairs of symbols
% separated by \EXTENDS{}, as needed for type parameter declarations.
% Parameters: Type parameter name, bound name, number of type parameters.
\newcommand{\FTTypeParameters}[3]{\ensuremath{%
  {#1}_1\FunctionTypeExtends{#2}_1,\,\ldots,\ %
  {#1}_{#3}\FunctionTypeExtends{#2}_{#3}}}

% Used to specify simple non-generic function types: Same syntax as in source.
% Arguments: Return type, formal parameter declarations.
\newcommand{\FunctionTypeSimple}[2]{\code{\ensuremath{#1}\ \FUNCTION({#2})}}

% Used to specify simple generic function types: Same syntax as in source.
% Arguments: Return type, formal parameter declarations.
\newcommand{\FunctionTypeSimpleGeneric}[3]{\code{%
  \ensuremath{#1}\ \FUNCTION<{#2}>({#3})}}

% Used to specify function types: Same syntax as in source.
% Arguments: Return type, spacer, type parameter name, bound name,
%   number of type parameters, formal parameter declarations.
\newcommand{\FunctionType}[6]{\leavevmode\par\noindent\code{%
  \ensuremath{#1}{#2}\FUNCTION<\FTTypeParameters{#3}{#4}{#5}>({#6})}}

% Same as \FunctionType except suitable for inline usage, hence omitting
% the spacer argument.
\newcommand{\RawFunctionType}[5]{\code{%
  \ensuremath{#1}\ \FUNCTION<\FTTypeParameters{#2}{#3}{#4}>({#5})}}

% Used to specify function type parameter lists with positional optionals.
% Arguments: Parameter type, number of required parameters,
%   number of optional parameters.
%
% For example, \FunctionTypePositionalParameters{T}{n}{k} yields
% approximately "T1, .. Tn, [Tn+1, .. Tn+k]".
\newcommand{\FunctionTypePositionalParameters}[3]{%
  \List{#1}{1}{#2},\ [\List{#1}{{#2}+1}{{#2}+{#3}}]}

% Used to specify a standard positional function type, that is, a function
% type with positional optional parameters which uses the symbols we prefer
% to use for that purpose whenever possible.
%
% Approximately "T1, .. Tn, [Tn+1, .. Tn+k]".
\newcommand{\FunctionTypePositionalParametersStd}{%
  \FunctionTypePositionalParameters{T}{n}{k}}

% Used to specify function type parameter lists with named optionals.
% Arguments: Parameter type, number of required parameters,
%   name of optional parameters, number of optional parameters.
%
% For example \FunctionTypeNamedParameters{T}{n}{x}{k}{r} yields approximately
% "T1, .. Tn, {rn+1 Tn+1 xn+1, .. rn+k Tn+k xn+k}".
\newcommand{\FunctionTypeNamedParameters}[5]{%
  \List{#1}{1}{#2},\ \{\TripleList{#5}{#1}{#3}{{#2}+1}{{#2}+{#4}}\}}
  
% Variant of \FunctionTypeNamedParameters that uses the standard symbols,
% that is, a list of function type parameter declarations with named
% parameters which uses the symbols that we prefer to use for that purpose
% whenever possible.
%
% Approximately "T1, .. Tn, {rn+1 Tn+1 xn+1, .. rn+k Tn+k xn+k}".
\newcommand{\FunctionTypeNamedParametersStd}{%
  \FunctionTypeNamedParameters{T}{n}{x}{k}{r}}

% Used to specify function types with positional optionals:
% Arguments: Return type, spacer, type parameter name, bound name,
%   number of type parameters, parameter type, number of required parameters,
%   number of optional parameters.
%
% For example, \FunctionTypePositional{R}{ }{X}{B}{s}{T}{n}{k} yields
% approximately
% "R Function<X1 extends B1, .. Xs extends Bs>(T1, .. Tn, [Tn+1, .. Tn+k])".
\newcommand{\FunctionTypePositional}[8]{%
  \FunctionType{#1}{#2}{#3}{#4}{#5}{%
    \FunctionTypePositionalParameters{#6}{#7}{#8}}}

% Same as \FunctionTypePositional except suitable for inline usage,
% hence omitting the spacer argument.
\newcommand{\RawFunctionTypePositional}[7]{%
  \RawFunctionType{#1}{#2}{#3}{#4}{%
    \FunctionTypePositionalParameters{#5}{#6}{#7}}}

% A variant of \FunctionTypePositional that uses the standard symbols,
% that is, a function type with positional optional parameters which
% uses the symbols that we prefer to use for that purpose whenever
% possible.
%
% For example, \FunctionTypePositionalStd{R} yields approximately
% "R Function<X1 extends B1, .. Xs extends Bs>(T1, T2, .. Tn, [Tn+1 .. Tn+k])".
\newcommand{\FunctionTypePositionalStd}[1]{%
  \FunctionTypePositional{#1}{ }{X}{B}{s}{T}{n}{k}}

% Same as \FunctionTypePositionalStd except suitable for inline usage,
% hence omitting the spacer argument.
\newcommand{\RawFunctionTypePositionalStd}[1]{%
  \RawFunctionTypePositional{#1}{X}{B}{s}{T}{n}{k}}

% Same as \FunctionTypePositionalStd except that it includes a newline, hence
% suitable for function types that are too long to fit in one line.
\newcommand{\FunctionTypePositionalStdCr}[1]{%
  \FunctionTypePositional{#1}{\\}{X}{B}{s}{T}{n}{k}}

% Used to specify function types with named parameters:
% Arguments: Return type, spacer, type parameter name, bound name,
%   number of type parameters, parameter type, number of required parameters,
%   name of optional parameters, number of optional parameters.
% The name of the `required` symbol is always `r` (because we can't have
% 10 arguments in a LaTeX command, and `r` is always OK in practice).
%
% For example, \FunctionTypeNamed{R}{ }{X}{B}{s}{T}{n}{x}{k} yields
% approximately "R Function<X1 extends B1, .. Xs extends Bs>(
%     T1, T2, .. Tn, {rn+1 Tn+1 xn+1, .. rn+k Tn+k xn+k])".
\newcommand{\FunctionTypeNamed}[9]{%
  \FunctionType{#1}{#2}{#3}{#4}{#5}{\\
    \mbox{}\qquad\FunctionTypeNamedParameters{#6}{#7}{#8}{#9}{r}}}

% Same as \FunctionTypeNamed except suitable for inline usage, hence omitting
% the spacer argument.
\newcommand{\RawFunctionTypeNamed}[9]{%
  \RawFunctionType{#1}{#2}{#3}{#4}{%
    \FunctionTypeNamedParameters{#5}{#6}{#7}{#8}{r}}}

% A variant of \FunctionTypeNamed that uses the standard symbols,
% that is, a function type with positional optional parameters which
% uses the symbols that we prefer to use for that purpose whenever
% possible.
%
% For example, \FunctionTypeNamedStd{R} yields approximately
% "R Function<X1 extends B1, .. Xs extends Bs>(
%     T1, T2, .. Tn, {rn+1 Tn+1 xn+1, .. rn+k Tn+k xn+k})".
\newcommand{\FunctionTypeNamedStd}[1]{%
  \FunctionTypeNamed{#1}{ }{X}{B}{s}{T}{n}{x}{k}}

% Same as \FunctionTypeNamedStd except suitable for inline usage, hence
% omitting the spacer argument.
\newcommand{\RawFunctionTypeNamedStd}[1]{%
  \RawFunctionTypeNamed{#1}{X}{B}{s}{T}{n}{x}{k}{r}}

% Same as \FunctionTypeNamedStd except that it includes a newline, hence
% suitable for function types that are too long to fit in one line.
\newcommand{\FunctionTypeNamedStdCr}[1]{%
  \FunctionTypeNamed{#1}{\\}{X}{B}{s}{T}{n}{x}{k}}

% Used to specify function types with no optional parameters:
% Arguments: Return type, spacer, type parameter name, bound name,
%   number of type parameters, parameter type,
%   number of parameters (all required).
%
% For example, \FunctionTypeAllRequired{R}{ }{X}{B}{s}{T}{n} yields
% approximately "R Function<X1 extends B1, .. Xs extends Bs>(T1, T2, .. Tn)".
\newcommand{\FunctionTypeAllRequired}[7]{%
  \FunctionType{#1}{#2}{#3}{#4}{#5}{\List{#6}{1}{#7}}}

% A variant of \FunctionTypeAllRequired that uses the standard symbols,
% that is, a function type with positional optional parameters which
% uses the symbols that we prefer to use for that purpose whenever
% possible.
%
% For example, \FunctionTypeAllRequiredStd{R} yields approximately
% "R Function<X1 extends B1, .. Xs extends Bs>(T1, T2, .. Tn)".
\newcommand{\FunctionTypeAllRequiredStd}[1]{%
  \FunctionTypeAllRequired{#1}{ }{X}{B}{s}{T}{n}}

% Same as \FunctionTypeAllRequiredStd except that it includes a newline, hence
% suitable for function types that are too long to fit in one line.
\newcommand{\FunctionTypeAllRequiredStdCr}[1]{%
  \FunctionTypeAllRequired{#1}{\\}{X}{B}{s}{T}{n}}

\newcommand{\MoreSignatureSpecificSymbol}{\ensuremath{\preceq}}
\newcommand{\NotMoreSignatureSpecificSymbol}{\ensuremath{\not\preceq}}
\newcommand{\LessSignatureSpecificSymbol}{\ensuremath{\succeq}}

\newcommand{\MoreSignatureSpecific}[2]{%
  \ensuremath{{#1}\MoreSignatureSpecificSymbol{#2}}}
\newcommand{\NotMoreSignatureSpecific}[2]{%
  \ensuremath{{#1}\NotMoreSignatureSpecificSymbol{#2}}}

% Judgment expressing that a subtype relation exists.
\newcommand{\Subtype}[3]{\ensuremath{{#1}\vdash{#2}\,<:\,{#3}}}
\newcommand{\SubtypeStd}[2]{\Subtype{\Delta}{#1}{#2}}
% Subtype judgment where the environment is omitted (NE: "no environment").
\newcommand{\SubtypeNE}[2]{\ensuremath{{#1}\,<:\,{#2}}}
\newcommand{\MutualSubtype}[3]{\ensuremath{{#1}\vdash{#2}\,<:>\,{#3}}}
\newcommand{\MutualSubtypeStd}[2]{\MutualSubtype{\Delta}{#1}{#2}}
\newcommand{\MutualSubtypeNE}[2]{\ensuremath{{#1}\,<:>\,{#2}}}

% Judgment expressing that a supertype relation exists.
\newcommand{\Supertype}[3]{\ensuremath{{#1}\vdash{#2}\,:>\,{#3}}}
\newcommand{\SupertypeStd}[2]{\Supertype{\Delta}{#1}{#2}}

% Semantic function delivering the superinterfaces of a class.
\newcommand{\Superinterfaces}[1]{\ensuremath{\metavar{Superinterfaces}({#1})}}
\newcommand{\Superinterface}[2]{{#1}\in\Superinterfaces{#2}}

% Namespaces, needed in the specification of imports and exports, and
% also used when specifying lookups and scope rules.
\newcommand{\NamespaceName}[1]{\ensuremath{\metavar{NS}_{#1}}}
\newcommand{\Namespace}[2]{\ensuremath{\NamespaceName{#1}({#2})}}

% Functions used in the specification of the namespace combinators
% `show` and `hide`.
\newcommand{\ShowName}{\metavar{show}}
\newcommand{\HideName}{\metavar{hide}}
\newcommand{\Show}[2]{\ensuremath{\ShowName({#1},{#2})}}
\newcommand{\Hide}[2]{\ensuremath{\HideName({#1},{#2})}}

% A special value in a namespace, used to indicate a conflict.
\newcommand{\ConflictValue}{\mbox{NAME\_CONFLICT}}

% Context types: Avoid the `?` because that is also concrete type
% syntax.
%% TODO(eernst): Find a suitable symbol for this, e.g., a curly questionmark.
\newcommand{\FreeContext}{\ensuremath{\raisebox{0.25ex}{%
      \makebox[0pt][c]{\hspace{0.8em}\scriptsize?}}\square}}

% Sequences of objects used during collection literal evaluation: Just
% a specification concept, may or may not have an actual underlying
% data structure at run time.
\newcommand{\LiteralSequence}[1]{\ensuremath{[\![{#1}]\!]}}
\newcommand{\EvaluateElementName}{\metavar{evaluateElement}}
\newcommand{\EvaluateElement}[1]{\ensuremath{\EvaluateElementName({#1})}}

\newcommand{\DefEquals}[2]{\ensuremath{{#1}\stackrel{\vartriangle}{=}{#2}}}
\newcommand{\DefEqualsNewline}[2]{
  \ensuremath{{#1}\stackrel{\vartriangle}{=}}\\
  \ensuremath{{#2}}%
}

\newcommand{\FlattenName}{\metavar{flatten}}
\newcommand{\Flatten}[1]{\ensuremath{\FlattenName(\code{#1})}}

\newcommand{\NominalTypeDepthName}{\metavar{nominalTypeDepth}}
\newcommand{\NominalTypeDepth}[1]{%
  \ensuremath{\NominalTypeDepthName(\code{#1})}}

\newcommand{\TopMergeTypeName}{\metavar{topMergeType}}
\newcommand{\TopMergeType}[2]{%
  \ensuremath{\TopMergeTypeName(\code{{#1},\,\,{#2}})}}

\newcommand{\NonNullTypeName}{\metavar{nonNullType}}
\newcommand{\NonNullType}[1]{\ensuremath{\NonNullTypeName(\code{#1})}}

\newcommand{\IsTopTypeName}{\metavar{isTopType}}
\newcommand{\IsTopType}[1]{\ensuremath{\IsTopTypeName(\code{#1})}}

\newcommand{\IsObjectTypeName}{\metavar{isObjectType}}
\newcommand{\IsObjectType}[1]{\ensuremath{\IsObjectTypeName(\code{#1})}}

\newcommand{\IsBottomTypeName}{\metavar{isBottomType}}
\newcommand{\IsBottomType}[1]{\ensuremath{\IsBottomTypeName(\code{#1})}}

\newcommand{\IsNullTypeName}{\metavar{isNullType}}
\newcommand{\IsNullType}[1]{\ensuremath{\IsNullTypeName(\code{#1})}}

\newcommand{\IsMoreTopTypeName}{\metavar{isMoreTopType}}
\newcommand{\IsMoreTopType}[2]{%
  \ensuremath{\IsMoreTopTypeName(\code{{#1},\,\,{#2}})}}

\newcommand{\IsMoreBottomTypeName}{\metavar{isMoreBottomType}}
\newcommand{\IsMoreBottomType}[2]{%
  \ensuremath{\IsMoreBottomTypeName(\code{{#1},\,\,{#2}})}}

\newcommand{\NormalizedTypeOfName}{\metavar{normalizedType}}
\newcommand{\NormalizedTypeOf}[1]{%
  \ensuremath{\NormalizedTypeOfName(\code{#1})}}

\newcommand{\FutureValueTypeOfName}{\metavar{futureValueType}}
\newcommand{\FutureValueTypeOf}[1]{%
  \ensuremath{\FutureValueTypeOfName(\code{#1})}}

\newcommand{\UpperBoundTypeName}{\metavar{standardUpperBound}}
\newcommand{\UpperBoundType}[2]{%
  \ensuremath{\UpperBoundTypeName(\code{{#1},\,\,{#2}})}}

\newcommand{\LowerBoundTypeName}{\metavar{standardLowerBound}}
\newcommand{\LowerBoundType}[2]{%
  \ensuremath{\LowerBoundTypeName(\code{{#1},\,\,{#2}})}}

% ----------------------------------------------------------------------
% Support for hash valued Location Markers

% very small font, to enable 40 char hash values in the margin
\makeatletter
\ifcase \@ptsize \relax% 10pt
  \newcommand{\miniscule}{\@setfontsize\miniscule{2}{3}}% \tiny: 5/6
\or% 11pt
  \newcommand{\miniscule}{\@setfontsize\miniscule{3}{4}}% \tiny: 6/7
\or% 12pt
  \newcommand{\miniscule}{\@setfontsize\miniscule{3}{4}}% \tiny: 6/7
\fi
\makeatother

% white: location markers should not create visual noise
\definecolor{LMdim}{gray}{1.0}

% insert location marker showing hash value of following paragraph
\newcommand{\LMHash}[1]{\leavevmode\marginpar{\quad%
    \raisebox{0.5ex}{\miniscule{\color{LMdim}#1}}\vspace{-2\baselineskip}}%
  \color{normativeColor}}

% support convenient renewcommand
\let\OriginalLMHash\LMHash

% define a label, and show the associated logical location marker
\newcommand{\LMLabel}[1]{%
  \vspace{-\baselineskip}\leavevmode\OriginalLMHash{\raisebox{10ex}{#1}}%
  \label{#1}}
% ----------------------------------------------------------------------

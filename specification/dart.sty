\def\builtinId#1{\textsf{\textbf{#1}}}
\def\keyword#1{\textsf{\textbf{#1}}}
\def\metavar#1{\ensuremath{\mathit{#1}}}

\def\ABSTRACT{\builtinId{abstract}}
\def\AS{\builtinId{as}}
\def\COVARIANT{\builtinId{covariant}}
\def\DEFERRED{\builtinId{deferred}}
\def\DYNAMIC{\builtinId{dynamic}}
\def\EXPORT{\builtinId{export}}
\def\EXTERNAL{\builtinId{external}}
\def\EXTENSION{\builtinId{extension}}
\def\FACTORY{\builtinId{factory}}
\def\FUNCTION{\builtinId{Function}}
\def\GET{\builtinId{get}}
\def\IMPLEMENTS{\builtinId{implements}}
\def\IMPORT{\builtinId{import}}
\def\INTERFACE{\builtinId{interface}}
\def\LIBRARY{\builtinId{library}}
\def\MIXIN{\builtinId{mixin}}
\def\OPERATOR{\builtinId{operator}}
\def\PART{\builtinId{part}}
\def\REQUIRED{\builtinId{required}}
\def\SET{\builtinId{set}}
\def\STATIC{\builtinId{static}}
\def\TYPEDEF{\builtinId{typedef}}

\def\ASSERT{\keyword{assert}}
\def\ASYNC{\keyword{async}}
\def\AWAIT{\keyword{await}}
\def\BREAK{\keyword{break}}
\def\CASE{\keyword{case}}
\def\CATCH{\keyword{catch}}
\def\CLASS{\keyword{class}}
\def\CONST{\keyword{const}}
\def\CONTINUE{\keyword{continue}}
\def\DEFAULT{\keyword{default}}
\def\DO{\keyword{do}}
\def\ELSE{\keyword{else}}
\def\ENUM{\keyword{enum}}
\def\EXTENDS{\keyword{extends}}
\def\FALSE{\keyword{false}}
\def\FINAL{\keyword{final}}
\def\FINALLY{\keyword{finally}}
\def\FOR{\keyword{for}}
\def\HIDE{\keyword{hide}}
\def\IF{\keyword{if}}
\def\IN{\keyword{in}}
\def\IS{\keyword{is}}
\def\LATE{\keyword{late}}
\def\NEW{\keyword{new}}
\def\NULL{\keyword{null}}
\def\OF{\keyword{of}}
\def\ON{\keyword{on}}
\def\RETHROW{\keyword{rethrow}}
\def\RETURN{\keyword{return}}
\def\SHOW{\keyword{show}}
\def\SUPER{\keyword{super}}
\def\SWITCH{\keyword{switch}}
\def\SYNC{\keyword{sync}}
\def\THIS{\keyword{this}}
\def\THROW{\keyword{throw}}
\def\TRUE{\keyword{true}}
\def\TRY{\keyword{try}}
\def\VAR{\keyword{var}}
\def\VOID{\keyword{void}}
\def\WHILE{\keyword{while}}
\def\WITH{\keyword{with}}
\def\YIELD{\keyword{yield}}

% Used to specify syntactic sugar.
\def\LET{\keyword{let}}

% Used for inline code snippets.
\def\code#1{\texttt{#1}}

% `call` has no special lexical status, so we just use \code{}.
\def\CALL{\code{call}}

% Define commands for `<<`, `>>`, `>>>` that avoid introducing guillemets.
\def\ltlt{<\mbox <}
\def\gtgt{>\mbox >}
\def\gtgtgt{>\mbox >\mbox >}

% Commands for single quotes, enabling them to be used
% in a `grammar` environment.
\def\sq{\mbox'}
\def\sqsq{\mbox{'{}'}}
\def\sqsqsq{\mbox{'{}'{}'}}

% Used as line break in the right hand side of a grammar
% alternative, that is, when starting a "continuation line".
\newcommand{\gnewline}{\leavevmode\\}

% Used in lexical grammar rules to express negation of a character or
% character set (which simply denotes the set of all other characters);
% also used to show the actual "tilde" character as source code.
\newcommand{\gtilde}{\mbox{\code{\textasciitilde}}}

% Metavariables for argument lists.
\newcommand{\argumentList}[1]{\metavar{{#1}s}}
\newcommand{\parameterList}[1]{\metavar{{#1}s}}

% Colors used for for different kinds of text.
\definecolor{normativeColor}{rgb}{0,0,0}
\definecolor{commentaryColor}{rgb}{0.5,0.5,0.5}
\definecolor{rationaleColor}{rgb}{0.5,0.5,0.5}

% Environments for different kinds of text.
\newenvironment{Q}[1]{{\bf{}Upcoming: {#1}}}{}
\newenvironment{rationale}[1]{{\color{rationaleColor}\it{#1}}}{}
\newenvironment{commentary}[1]{{\color{commentaryColor}\sf{#1}}}{}

% Auxiliary functions.
\newcommand{\flatten}[1]{\ensuremath{\mbox{\it flatten}({#1})}}
\newcommand{\futureOrBase}[1]{\ensuremath{\mbox{\it futureOrBase}({#1})}}
\newcommand{\overrides}[1]{\ensuremath{\mbox{\it overrides}({#1})}}
\newcommand{\inherited}[1]{\ensuremath{\mbox{\it inherited}({#1})}}

% Used as a mini-section marker, indicating visibly that a range of
% text (usually just a couple of paragraphs) are concerned with one
% specific topic in a list of similar topics (like many forms of
% expressions of a similar nature).
\newcommand{\Case}[1]{\textbf{Case }$\langle\hspace{0.1em}${#1}$\hspace{0.1em}\rangle$\textbf{.}}
\newcommand{\EndCase}{\mbox{}\hfill$\scriptscriptstyle\Box$\xspace}

\newenvironment{dartCode}[1][!ht] {%
  \def\@programcr{\@addfield\strut}%
  \let\\=\@programcr%
  \relax\@vobeyspaces\obeylines%
  \ttfamily\color{commentaryColor}%
  \vspace{1em}%
}{\normalcolor\vspace{1em}}

\newenvironment{normativeDartCode}[1][!ht] {%
  \def\@programcr{\@addfield\strut}%
  \let\\=\@programcr%
  \relax\@vobeyspaces\obeylines%
  \ttfamily\color{normativeColor}%
  \vspace{1em}%
}{\normalcolor\vspace{1em}}

% Used for comments in a code context.
\def\comment#1{\textsf{#1}}

% A commonly used metavariable for an identifier, operator.
\newcommand{\id}{\metavar{id}}
\newcommand{\op}{\metavar{op}}

% Used for defining occurrence of phrase, with customized index entry.
\newcommand{\IndexCustom}[2]{%
  \leavevmode\marginpar{\ensuremath{\diamond}}\emph{#1}\index{#2}}

% Used when one concept should have >1 entry in the index. Does not add
% the diamond in the margin and shows no text where the command occurs.
% Intended to be used immediately after another \Index... command.
\newcommand{\IndexExtraEntry}[1]{\index{#1}}

% Used for a defining occurrence of a phrase, adding it to the index.
\newcommand{\Index}[1]{\IndexCustom{#1}{#1}}

% Same appearance, but not adding an entry to the index.
\newcommand{\NoIndex}[1]{%
  \leavevmode\marginpar{\ensuremath{\diamond}}\emph{#1}}

% Used to specify comma separated lists of similar symbols.
\newcommand{\List}[3]{\ensuremath{{#1}_{#2},\,\ldots,\ {#1}_{#3}}}

% Used to specify comma separated lists of pairs of similar symbols,
% as needed, e.g., for declarations of formal parameters.
% Parameters: Name of first part of pair, name of second part,
% index at start, index at end.
\newcommand{\PairList}[4]{\ensuremath{%
  {#1}_{#3}\ {#2}_{#3},\,\ldots,\ {#1}_{#4}\ {#2}_{#4}}}

% Used to specify a list of tuples of the form $(K_j, V_j)$ which are
% used with collection literals.
\newcommand{\KeyValueTypeList}[4]{\ensuremath{%
  ({#1}_{#3},\,{#2}_{#3}),\,\ldots,\ ({#1}_{#4},\,{#2}_{#4})}}

% Used to specify a list of key/value pairs of the form $k_j: v_j$ which are
% used for the semantics of collection literals.
\newcommand{\KeyValueList}[4]{\ensuremath{%
  {#1}_{#3}:\,{#2}_{#3},\,\ldots,\ {#1}_{#4}:\,{#2}_{#4}}}

% Used to specify comma separated lists of triples of similar symbols,
% as needed, e.g., for declarations of formal parameters with defaults.
% Parameters: Name of first part of triple, name of second part,
% name of third part, index at start, index at end.
\newcommand{\TripleList}[5]{\ensuremath{%
  {#1}_{#4}\ {#2}_{#4}\ {#3}_{#4},\,\ldots,\ {#1}_{#5}\ {#2}_{#5}\ {#3}_{#5}}}

% Used to abbreviate \EXTENDS{} in function types.
\newcommand{\FunctionTypeExtends}{\ensuremath{\triangleleft}}

% Used to specify comma separated lists of pairs of symbols
% separated by \EXTENDS{}, as needed for type parameter declarations.
% Parameters: Type parameter name, bound name, number of type parameters.
\newcommand{\TypeParameters}[3]{\ensuremath{%
  {#1}_1\,\EXTENDS\,{#2}_1,\,\ldots,\ %
  {#1}_{#3}\,\EXTENDS\,{#2}_{#3}}}

% Used to specify comma separated lists of symbols followed by
% \EXTENDS{}, as needed for type parameter declarations where we do
% not intend to refer explicitly to the bounds.
% Parameters: Type parameter name, number of type parameters.
\newcommand{\TypeParametersNoBounds}[2]{\ensuremath{%
  {#1}_1\,\EXTENDS\,\ldots,\ \ldots,\ {#1}_{#2}\,\EXTENDS\,\ldots}}

% For consistency, we may as well use this whenever possible.
\newcommand{\TypeParametersStd}{\TypeParameters{X}{B}{s}}

% Used to specify comma separated lists of pairs of symbols
% separated by \EXTENDS{}, as needed for type parameter declarations.
% Parameters: Type parameter name, bound name, number of type parameters.
\newcommand{\FTTypeParameters}[3]{\ensuremath{%
  {#1}_1\FunctionTypeExtends{#2}_1,\,\ldots,\ %
  {#1}_{#3}\FunctionTypeExtends{#2}_{#3}}}

% Used to specify simple non-generic function types: Same syntax as in source.
% Arguments: Return type, formal parameter declarations.
\newcommand{\FunctionTypeSimple}[2]{\code{\ensuremath{#1}\ \FUNCTION({#2})}}

% Used to specify simple generic function types: Same syntax as in source.
% Arguments: Return type, formal parameter declarations.
\newcommand{\FunctionTypeSimpleGeneric}[3]{\code{%
  \ensuremath{#1}\ \FUNCTION<{#2}>({#3})}}

% Used to specify function types: Same syntax as in source.
% Arguments: Return type, spacer, type parameter name, bound name,
%   number of type parameters, formal parameter declarations.
\newcommand{\FunctionType}[6]{\leavevmode\par\noindent\code{%
  \ensuremath{#1}{#2}\FUNCTION<\FTTypeParameters{#3}{#4}{#5}>({#6})}}

% Same as \FunctionType except suitable for inline usage, hence omitting
% the spacer argument.
\newcommand{\RawFunctionType}[5]{\code{%
  \ensuremath{#1}\ \FUNCTION<\FTTypeParameters{#2}{#3}{#4}>({#5})}}

% Used to specify function type parameter lists with positional optionals.
% Arguments: Parameter type, number of required parameters,
% number of optional parameters.
\newcommand{\FunctionTypePositionalArguments}[3]{%
  \List{#1}{1}{#2},\ [\List{#1}{{#2}+1}{{#2}+{#3}}]}

\newcommand{\FunctionTypePositionalArgumentsStd}{%
  \FunctionTypePositionalArguments{T}{n}{k}}

% Used to specify function types with positional optionals:
% Arguments: Return type, spacer, type parameter name, bound name,
%   number of type parameters, parameter type, number of required parameters,
%   number of optional parameters.
\newcommand{\FunctionTypePositional}[8]{%
  \FunctionType{#1}{#2}{#3}{#4}{#5}{%
    \FunctionTypePositionalArguments{#6}{#7}{#8}}}

% Same as \FunctionTypePositional except suitable for inline usage,
% hence omitting the spacer argument.
\newcommand{\RawFunctionTypePositional}[7]{%
  \RawFunctionType{#1}{#2}{#3}{#4}{%
    \FunctionTypePositionalArguments{#5}{#6}{#7}}}

% Used to specify function type parameter lists with named optionals.
% Arguments: Parameter type, number of required parameters,
% name of optional parameters, number of optional parameters.
\newcommand{\FunctionTypeNamedArguments}[4]{%
  \List{#1}{1}{#2},\ \{\PairList{#1}{#3}{{#2}+1}{{#2}+{#4}}\}}
  
\newcommand{\FunctionTypeNamedArgumentsStd}{%
  \FunctionTypeNamedArguments{T}{n}{x}{k}}

% Used to specify function types with named parameters:
% Arguments: Return type, spacer, type parameter name, bound name,
%   number of type parameters, parameter type, number of required parameters,
%   name of optional parameters, number of optional parameters.
\newcommand{\FunctionTypeNamed}[9]{%
  \FunctionType{#1}{#2}{#3}{#4}{#5}{%
    \FunctionTypeNamedArguments{#6}{#7}{#8}{#9}}}

% Same as \FunctionType except suitable for inline usage, hence omitting
% the spacer argument.
\newcommand{\RawFunctionTypeNamed}[8]{%
  \RawFunctionType{#1}{#2}{#3}{#4}{%
    \FunctionTypeNamedArguments{#5}{#6}{#7}{#8}}}

% Used to specify function types with no optional parameters:
% Arguments: Return type, spacer, type parameter name, bound name,
%   number of type parameters, parameter type,
%   number of parameters (all required).
\newcommand{\FunctionTypeAllRequired}[7]{%
  \FunctionType{#1}{#2}{#3}{#4}{#5}{\List{#6}{1}{#7}}}

\newcommand{\FunctionTypePositionalStd}[1]{%
  \FunctionTypePositional{#1}{ }{X}{B}{s}{T}{n}{k}}

\newcommand{\RawFunctionTypePositionalStd}[1]{%
  \RawFunctionTypePositional{#1}{X}{B}{s}{T}{n}{k}}

\newcommand{\FunctionTypeNamedStd}[1]{%
  \FunctionTypeNamed{#1}{ }{X}{B}{s}{T}{n}{x}{k}}

\newcommand{\RawFunctionTypeNamedStd}[1]{%
  \RawFunctionTypeNamed{#1}{X}{B}{s}{T}{n}{x}{k}}

\newcommand{\FunctionTypeAllRequiredStd}[1]{%
  \FunctionTypeAllRequired{#1}{ }{X}{B}{s}{T}{n}}

\newcommand{\FunctionTypePositionalStdCr}[1]{%
  \FunctionTypePositional{#1}{\\}{X}{B}{s}{T}{n}{k}}

\newcommand{\FunctionTypeNamedStdCr}[1]{%
  \FunctionTypeNamed{#1}{\\}{X}{B}{s}{T}{n}{x}{k}}

\newcommand{\FunctionTypeAllRequiredStdCr}[1]{%
  \FunctionTypeAllRequired{#1}{\\}{X}{B}{s}{T}{n}}

\newcommand{\MoreSignatureSpecificSymbol}{\ensuremath{\preceq}}
\newcommand{\NotMoreSignatureSpecificSymbol}{\ensuremath{\not\preceq}}
\newcommand{\LessSignatureSpecificSymbol}{\ensuremath{\succeq}}

\newcommand{\MoreSignatureSpecific}[2]{%
  \ensuremath{{#1}\MoreSignatureSpecificSymbol{#2}}}
\newcommand{\NotMoreSignatureSpecific}[2]{%
  \ensuremath{{#1}\NotMoreSignatureSpecificSymbol{#2}}}

% Judgment expressing that a subtype relation exists.
\newcommand{\Subtype}[3]{\ensuremath{{#1}\vdash{#2}\,<:\,{#3}}}
\newcommand{\SubtypeStd}[2]{\Subtype{\Gamma}{#1}{#2}}
% Subtype judgment where the environment is omitted (NE: "no environment").
\newcommand{\SubtypeNE}[2]{\ensuremath{{#1}\,<:\,{#2}}}

% Judgment expressing that a supertype relation exists.
\newcommand{\Supertype}[3]{\ensuremath{{#1}\vdash{#2}\,:>\,{#3}}}
\newcommand{\SupertypeStd}[2]{\Supertype{\Gamma}{#1}{#2}}

% Judgment expressing that an assignability relation exists.
\newcommand{\AssignableRelationSymbol}{\ensuremath{\Longleftrightarrow}}
\newcommand{\Assignable}[3]{%
  \ensuremath{{#1}\vdash{#2}\,\AssignableRelationSymbol\,{#3}}}
\newcommand{\AssignableStd}[2]{\Assignable{\Gamma}{#1}{#2}}

% Semantic function delivering the superinterfaces of a class.
\newcommand{\Superinterfaces}[1]{\ensuremath{\metavar{Superinterfaces}({#1})}}
\newcommand{\Superinterface}[2]{{#1}\in\Superinterfaces{#2}}

% Namespaces, needed in the specification of imports and exports, and
% also used when specifying lookups and scope rules.
\newcommand{\NamespaceName}[1]{\ensuremath{\metavar{NS}_{#1}}}
\newcommand{\Namespace}[2]{\ensuremath{\NamespaceName{#1}({#2})}}

% Functions used in the specification of the namespace combinators
% `show` and `hide`.
\newcommand{\ShowName}{\metavar{show}}
\newcommand{\HideName}{\metavar{hide}}
\newcommand{\Show}[2]{\ensuremath{\ShowName({#1},{#2})}}
\newcommand{\Hide}[2]{\ensuremath{\HideName({#1},{#2})}}

% A special value in a namespace, used to indicate a conflict.
\newcommand{\ConflictValue}{\mbox{NAME\_CONFLICT}}

% Context types: Avoid the `?` because that is also concrete type
% syntax.
%% TODO(eernst): Find a suitable symbol for this, e.g., a curly questionmark.
\newcommand{\FreeContext}{\ensuremath{\raisebox{0.25ex}{%
      \makebox[0pt][c]{\hspace{0.8em}\scriptsize?}}\square}}

% Sequences of objects used during collection literal evaluation: Just
% a specification concept, may or may not have an actual underlying
% data structure at run time.
\newcommand{\LiteralSequence}[1]{\ensuremath{[\![{#1}]\!]}}
\newcommand{\EvaluateElementName}{\metavar{evaluateElement}}
\newcommand{\EvaluateElement}[1]{\ensuremath{\EvaluateElementName({#1})}}

% ----------------------------------------------------------------------
% Support for hash valued Location Markers

% very small font, to enable 40 char hash values in the margin
\makeatletter
\ifcase \@ptsize \relax% 10pt
  \newcommand{\miniscule}{\@setfontsize\miniscule{2}{3}}% \tiny: 5/6
\or% 11pt
  \newcommand{\miniscule}{\@setfontsize\miniscule{3}{4}}% \tiny: 6/7
\or% 12pt
  \newcommand{\miniscule}{\@setfontsize\miniscule{3}{4}}% \tiny: 6/7
\fi
\makeatother

% white: location markers should not create visual noise
\definecolor{LMdim}{gray}{1.0}

% insert location marker showing hash value of following paragraph
\newcommand{\LMHash}[1]{\leavevmode\marginpar{\quad%
    \raisebox{0.5ex}{\miniscule{\color{LMdim}#1}}\vspace{-2\baselineskip}}%
  \color{normativeColor}}

% support convenient renewcommand
\let\OriginalLMHash\LMHash

% define a label, and show the associated logical location marker
\newcommand{\LMLabel}[1]{%
  \vspace{-\baselineskip}\leavevmode\OriginalLMHash{\raisebox{10ex}{#1}}%
  \label{#1}}
% ----------------------------------------------------------------------
